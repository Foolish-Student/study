# 🌟 Dijkstra 算法入门笔记（新手向）

## 1️⃣ Dijkstra 是什么？

Dijkstra 算法是一种**最短路径算法**，用于计算**从一个起点到所有其他点的最短距离**（前提是**边的权重非负**）。
它的核心思想是：

> 每次找出当前**距离起点最近**的点，把它“确定”下来，然后用它去更新其他点的距离。

适合场景：

* 地图导航（计算最短路线 🚗）
* 网络传输（最短延迟路径）
* 游戏寻路（AI 移动路线）

---

## 2️⃣ 核心概念

* **图（Graph）**：由\*\*点（顶点）**和**边（Edge）\*\*组成
* **权重（Weight）**：每条边的花费（距离、时间、费用等）
* **起点（Source）**：从哪个点开始计算
* **最短路径（Shortest Path）**：起点到某个点的最小花费路线

---

## 3️⃣ 核心思路（简单理解版）

可以把 Dijkstra 理解成“**贪心地扩展最短路径**”：

1. **初始化**

    * 起点距离设为 0
    * 其他点距离设为无穷大（INF）
    * 所有点都标记为“未确定”

2. **循环执行**

    * 从“未确定”的点中找出**当前距离最小**的点 `u`
    * 把 `u` 标记为“已确定”
    * 用 `u` 去更新它能到达的所有邻居的最短距离

      > 如果 `dist[u] + w(u, v) < dist[v]`，就更新 `dist[v]`

3. **结束条件**

    * 所有点都被确定
    * 或者剩下的点都不可达

---

## 4️⃣ 算法步骤（文字版）

假设：

* `dist[i]`：起点到 `i` 的最短距离
* `used[i]`：点 `i` 是否已确定
* `graph[u][v]`：u 到 v 的边权，INF 表示没有边

流程：

1. `dist[source] = 0`，其他 `dist = INF`
2. 循环 `n` 次：

    * 找到**未确定**的、`dist` 最小的点 `u`
    * 标记 `used[u] = true`
    * 遍历所有点 `v`：

        * 如果 `graph[u][v]` 有边，并且 `v` 未确定
        * 更新 `dist[v] = min(dist[v], dist[u] + graph[u][v])`

---

## 5️⃣ 时间复杂度

* **朴素实现**（二维数组存图）：O(n²)
* **堆优化实现**（邻接表 + 优先队列）：O(m log n)

    * 其中 n 是点数，m 是边数

新手入门建议先用 O(n²) 的朴素版本，因为更容易理解。

---

## 6️⃣ 注意事项（新手常犯的坑）

1. **图存储**

    * 如果用二维数组存储，`INF` 必须足够大（比如 `1e9`）
    * 自己到自己的距离必须是 0

2. **找最小点时**

    * 要确保是“未确定”的点
    * 如果所有剩余点都是 `INF`，直接结束循环

3. **下标问题**

    * 如果题目点是 1\~n，要开 `n+1` 大小的数组

4. **不能处理负权边**

    * 如果边权可能是负数，要用 **Bellman-Ford** 或 **SPFA**

---

## 7️⃣ 小例子

**输入**：

```
5 7 1
1 2 10
1 3 3
2 3 1
3 2 4
2 4 2
3 4 8
3 5 2
```

* 5 个点，7 条边，起点是 1
* 输出：

```
0 7 3 9 5
```

* 含义：从 1 到 1/2/3/4/5 的最短距离

---

## 8️⃣ 总结

Dijkstra 的本质就是：

> 不断选出离起点最近的点，并用它更新其他点的距离，直到所有点都确定。

新手建议：

* 先用二维数组 + O(n²) 版本写熟练
* 再学堆优化的 O(m log n) 版本
* 多画图、多手算一遍流程，理解“确定一个点”是什么意思

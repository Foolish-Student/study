# 三种常用分区方法对比笔记

## 1. Lomuto 分区（单向扫描）

### 原理

* 选定 pivot（通常选末尾 `a[right]`）。
* 用指针 `i` 表示 `< pivot` 区间的下一个位置。
* 用 `j` 从左到右扫描 `[left, right-1]`：

  * 若 `a[j] < pivot`，交换 `a[i]` 与 `a[j]`，`i++`。
* 扫描结束后，将 pivot 放到 `a[i]` 位置，返回 `i`。

### 特点

* 实现简单好记。
* 相等值全部归到右边。
* 每遇 `< pivot` 都交换，交换次数多。
* 极端情况下（大量相等值或接近有序）可能退化。

### 代码示例

```cpp
int partition_lomuto(int left, int right) {
    int pivot = a[right];
    int i = left;
    for (int j = left; j < right; ++j) {
        if (a[j] < pivot) swap(a[i++], a[j]);
    }
    swap(a[i], a[right]);
    return i;
}
```

---

## 2. Hoare 分区（双向扫描）

### 原理

* 选定 pivot（通常选中点 `a[(left+right)/2]`）。
* 指针 `i` 从左向右找 `>= pivot`，`j` 从右向左找 `<= pivot`。
* 若 `i <= j`，交换 `a[i]` 和 `a[j]`，然后 `i++`，`j--`。
* 循环结束时返回切分点 `j`，左区间 `[left, j]`，右区间 `[i, right]`。

### 特点

* 交换次数少，平均性能好。
* 相等值会分散到两边，分区更平衡。
* 边界条件较复杂，要注意递归区间包含端点。
* 分区结束后 `i = j+1`。

### 代码示例

```cpp
int partition_hoare(int left, int right) {
    int pivot = a[(left + right) / 2];
    int i = left, j = right;
    while (true) {
        while (a[i] < pivot) ++i;
        while (a[j] > pivot) --j;
        if (i >= j) return j;
        swap(a[i++], a[j--]);
    }
}
```

---

## 3. 三路分区（3-way / Dutch National Flag）

### 原理

* 选定 pivot（通常 `a[left]`）。
* 用三个指针：

  * `lt`：`< pivot` 区间的右边界（初始 `lt=left`）。
  * `gt`：`> pivot` 区间的左边界（初始 `gt=right`）。
  * `i`：当前扫描位置（初始 `i=left+1`）。
* 当 `i <= gt`：

  * `a[i] < pivot`：交换 `a[lt]` 与 `a[i]`，`lt++`，`i++`
  * `a[i] > pivot`：交换 `a[i]` 与 `a[gt]`，`gt--`（`i` 不变）
  * `a[i] == pivot`：`i++`

### 特点

* 数据有大量相等值时效率极高（一次跳过等于 pivot 的段）。
* 左区 `< pivot`，中区 `== pivot`，右区 `> pivot`。
* 递归/选择时可以直接跳过中区。

### 代码示例

```cpp
void three_way_partition(int left, int right, int k) {
    if (left >= right) return;
    int pivot = a[left];
    int lt = left, i = left + 1, gt = right;
    while (i <= gt) {
        if (a[i] < pivot) swap(a[lt++], a[i++]);
        else if (a[i] > pivot) swap(a[i], a[gt--]);
        else i++;
    }
    if (k < lt) three_way_partition(left, lt - 1, k);
    else if (k > gt) three_way_partition(gt + 1, right, k);
    else return; // k 在中间区，直接命中
}
```

---

## 总结对比表

| 方法          | 扫描方向    | 分区结果（示意）                           | 相等值分布 | 交换次数 | 适用场景     | 备注                          |
| ----------- | ------- | ---------------------------------- | ----- | ---- | -------- | --------------------------- |
| Lomuto      | 单向（左→右） | `< pivot` , `pivot` , `>= pivot`   | 全在右侧  | 多    | 实现简单、小数据 | 大量相等值时易退化                   |
| Hoare       | 双向      | `<= pivot` , `>= pivot`            | 分散两边  | 少    | 常用、性能均衡  | 注意递归区间用 `[l..j]` 和 `[i..r]` |
| 三路分区（3-way） | 单向多指针   | `< pivot` , `== pivot` , `> pivot` | 中间一段  | 视数据  | 大量重复值    | 快选时可直接跳过等值段，效率高             |

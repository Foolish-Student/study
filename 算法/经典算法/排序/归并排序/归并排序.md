# 归并排序（Merge Sort）
## 1️⃣ 归并排序的核心思想

它是一种 **分治（Divide and Conquer）** 思想的排序算法：

1. **分**：把数组不断拆成更小的部分，直到每个部分只有一个元素（一个元素是天然有序的）。
2. **治**：把两个有序的小部分合并成一个更大的有序部分。
3. **合并直到结束**：重复合并，最终得到一个完整的有序数组。

---

## 2️⃣ 执行过程举例

假设我们要排序 `[4, 2, 5, 1, 3]`

**分的过程：**

```
[4, 2, 5, 1, 3]
→ [4, 2, 5]   [1, 3]
→ [4, 2] [5]   [1] [3]
→ [4] [2] [5]   [1] [3]
```

**治（合并）的过程：**

* \[4] 和 \[2] 合并成 \[2, 4]
* \[2, 4] 和 \[5] 合并成 \[2, 4, 5]
* \[1] 和 \[3] 合并成 \[1, 3]
* \[2, 4, 5] 和 \[1, 3] 合并成 \[1, 2, 3, 4, 5]

---

## 3️⃣ 关键点

* **递归实现**：分的过程天然适合递归
* **合并过程**：需要一个额外的临时数组，把两个有序段按大小比较，依次放入临时数组
* **时间复杂度**：

    * 最坏、最好、平均都是 **O(n log n)**
* **空间复杂度**：

    * 需要额外 O(n) 空间来存放合并结果

---

## 4️⃣ 优缺点

**优点**：

* 稳定排序（相同元素相对位置不变）
* 时间复杂度稳定 O(n log n)

**缺点**：

* 需要额外 O(n) 空间
* 在小规模数据时不如插入排序快

---

## 5️⃣ 小技巧

* 归并排序特别适合 **链表排序**（因为链表拆分和合并都很方便）
* 在递归到子数组很小时，可以切换成插入排序优化性能
* 也可以用 **迭代版归并**，减少递归开销

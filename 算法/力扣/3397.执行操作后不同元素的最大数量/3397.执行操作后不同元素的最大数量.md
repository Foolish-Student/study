## 3397.执行操作后不同元素的最大数量

---

### 📖 题目描述

给你一个整数数组 `nums` 和一个整数 `k`。

你可以对数组中的每个元素 **最多执行一次** 以下操作：

> 将一个在范围 `[-k, k]` 内的整数加到该元素上。

返回执行这些操作后，`nums` 中可能拥有的 **不同元素的最大数量**。

---

#### 示例 1

```
输入：nums = [1,2,2,3,3,4], k = 2
输出：6
解释：
对前四个元素执行操作，nums 变为 [-1,0,1,2,3,4]，可获得 6 个不同的元素。
```

#### 示例 2

```
输入：nums = [4,4,4,4], k = 1
输出：3
解释：
对 nums[0] 加 -1，对 nums[1] 加 1，得到 [3,5,4,4]，共有 3 个不同元素。
```

---

### 💡 思路解析

题目允许我们对每个数 `nums[i]` 加上或减去一个范围在 `[-k, k]` 的整数，且每个元素只能操作一次。
目标是让数组中不同的数尽可能多。

#### 1️⃣ 关键观察

每个数 `num` 的可取值范围是一个闭区间：
[
[num - k, , num + k]
]
我们要从这些区间中选择一个具体的整数，使得所有选择的整数**尽可能不同且合法**。

这相当于一个**区间贪心问题**：在若干区间中选择尽量多的不重叠整数。

---

#### 2️⃣ 贪心策略

核心思想：
**让较小的区间尽可能早选，且每次都选“当前可选的最小整数”**。

为了实现这一点：

1. 先对数组 `nums` 排序。
2. 用变量 `lastNum` 记录上一个已经选过的整数。
3. 遍历每个数 `num`，它能选择的范围是 `[num - k, num + k]`。

   * 我们希望选择一个比 `lastNum` 大 1 的整数，以保持严格递增且不冲突；
   * 同时，不能超过 `num + k`。
   * 因此选取规则为：
     [
     n = \min(\max(lastNum + 1, num - k), num + k)
     ]
4. 如果 `n` 仍大于 `lastNum`，说明合法，可以计入结果并更新 `lastNum = n`。

---

#### 3️⃣ 示例演示

以题目示例：

```
nums = [1,2,2,3,3,4], k = 2
```

为例。

| 原数 | 区间      | 可选最小不冲突值 | 选取结果 |
| -- | ------- | -------- | ---- |
| 1  | [-1, 3] | -1       | ✅    |
| 2  | [0, 4]  | 0        | ✅    |
| 2  | [0, 4]  | 1        | ✅    |
| 3  | [1, 5]  | 2        | ✅    |
| 3  | [1, 5]  | 3        | ✅    |
| 4  | [2, 6]  | 4        | ✅    |

最终结果：`[-1, 0, 1, 2, 3, 4]`，共 6 个不同数。

输出：`6` ✅

---

### ⚙️ 复杂度分析

| 项目    | 复杂度                  |
| ----- | -------------------- |
| 时间复杂度 | O(n log n)，排序 + 单次遍历 |
| 空间复杂度 | O(1)，只用常数空间记录状态      |

---

### 🧠 总结

| 要点   | 内容                                  |
| ---- | ----------------------------------- |
| 问题类型 | 区间贪心问题                              |
| 关键操作 | 为每个 `[num - k, num + k]` 区间分配一个递增整数 |
| 贪心策略 | 每次取不冲突的最小可行值                        |
| 结果含义 | 最大可能的不同整数数量                         |

**一句话总结：**

> 先排序，再用贪心思想，从左到右为每个元素分配不重叠的最小可行值，最终得到最多不同数的个数。

# 778.水位上升的泳池中游泳

## 🧩 一、题目直观理解

你在一个正方形网格上游泳，
每个格子的数值 `grid[i][j]` 表示平台的高度。

下雨之后，水位会**随时间 t 逐渐上升**（也就是水位 = 时间）。
你从左上角 `(0, 0)` 出发，目标是到右下角 `(n-1, n-1)`。

但有一个限制条件：

> 只有当**当前水位 ≥ 相邻两个格子的高度**时，
> 你才能在这两个格子之间游动。

问：最早在什么时候（即最小的 t）能从起点游到终点？

---

## 🌊 二、问题抽象成图模型

我们可以把整个网格抽象为一个**加权图**：

* 每个单元格是一个节点；
* 相邻的上下左右格子之间存在一条边；
* 每条边的“代价” = 两个格子中较高的那个高度。
  因为水位必须至少高到能淹没这两个格子，才能在它们之间通过。

---

### 举个例子：

```
grid = [
  [0, 2],
  [1, 3]
]
```

边的代价如下：

```
(0,0) —(2)— (0,1)
  |             |
 (1)           (3)
  |             |
(1,0) —(3)— (1,1)
```

要从 `(0,0)` 走到 `(1,1)`，
我们要走一条路径，使得路径上所有边的“最大高度”尽可能小。

👉 **这其实是一个最小化“路径上最大值”的问题。**

---

## 💡 三、核心思路：最小化路径的“最大高度”

我们可以把问题表述成：

> 找一条从起点到终点的路径，使路径上遇到的最高平台高度最小。

这类问题非常类似于“最短路径”问题，只不过：

* 传统的最短路径（Dijkstra）是**累加路径代价**；
* 本题的路径代价是**路径上的最大值**。

因此我们可以使用一种“改版的 Dijkstra 算法”来解决。

---

## 🧭 四、算法设计思路（基于 Dijkstra + 贪心）

1. **从起点 (0,0) 开始**，初始水位为 `grid[0][0]`。
   因为你一开始就要淹没起点。

2. **使用优先队列（最小堆）**，
   每次从当前能到达的格子中，选择“高度最低”的那个格子扩展。
   这保证了我们每次走的是“当前水位最小的方向”。

3. **维护一个二维数组 `distTo[i][j]`**，
   表示到达 `(i, j)` 所需要的**最小水位**（也就是路径上最大高度的最小值）。

4. 对每个当前节点 `(x, y)`：

   * 遍历四个方向 `(dx, dy)`；
   * 如果邻格 `(nx, ny)` 没访问过：

     * 计算 `newHeight = max(distTo[x][y], grid[nx][ny])`
       （这代表走到下一个格子后水位要淹没两者的最大高度）
     * 如果 `newHeight < distTo[nx][ny]`，说明找到更优路径：

       * 更新 `distTo[nx][ny] = newHeight`
       * 把 `(newHeight, nx, ny)` 加入最小堆。

5. 当我们到达 `(n-1, n-1)` 时，
   对应的 `distTo[n-1][n-1]` 就是所需的最小时间。

---

## 🧠 五、算法核心思想总结

| 概念       | 含义                        |
| -------- | ------------------------- |
| **搜索方向** | 从起点出发，优先走“水位较低”的方向（贪心思想）  |
| **数据结构** | 最小堆（优先队列）用于每次取出当前最容易游到的格子 |
| **状态更新** | 每次到达新格子时，更新该格子所需的最小水位     |
| **终止条件** | 当到达终点 `(n-1, n-1)` 时立即返回  |

---

## 🧩 六、算法与 Dijkstra 的关系

* 传统 Dijkstra：
  每条边的权重是加法：`dist[v] = dist[u] + weight(u, v)`
* 本题 Dijkstra 改版：
  每条边的权重是取最大值：`dist[v] = max(dist[u], grid[v])`

虽然形式不同，但本质相同：

> 每次都优先选择“当前最容易到达”的节点扩展。

这就是**“贪心 + 最短路径”思想的结合**。

---

## ⚙️ 七、复杂度分析

* **时间复杂度**：
  每个格子最多进堆一次，堆操作是 O(log n²)，
  所以总体复杂度为 **O(n² log n)**。

* **空间复杂度**：
  需要维护访问数组和距离数组，均为 **O(n²)**。

---

## 🚀 八、思路总结一句话

> 用优先队列模拟水位上升过程，
> 每次扩展当前能“淹没”的最低格子，
> 直到终点被淹没的那一刻，就是你能游过去的最早时间。

---

是否希望我帮你画一张图（可视化）来展示“水位如何一层层上涨直到连通起点与终点”？
这能让整个 Dijkstra 贪心过程更直观。

# 题目
给定一个只包含数字的字符串 `s`，不断对其执行如下操作：从左到右取每一对相邻数字 `(s[i], s[i+1])`，计算它们的和并对 10 取模，将结果依次组成新的字符串。重复操作直到字符串只剩下两个数字，若这两个数字相等，则返回 `true`，否则返回 `false`。

---

## 🧩 思路分析

1. **模拟题核心：层层迭代压缩**

   * 每次操作都会使字符串长度减少 1。
   * 若原始字符串长度为 `n`，最终会经过 `n - 2` 次操作，剩下 2 个字符。
   * 在每一层操作中，新的字符串由相邻两位数字 `(s[j], s[j+1])` 计算得出：
     [
     s'[j] = ((s[j] - '0') + (s[j+1] - '0')) \mod 10
     ]
   * 然后再将 `s'` 作为新的字符串继续迭代。

2. **逐层更新字符串**

   * 从第一层开始，遍历所有可能的相邻对。
   * 每次计算后直接更新原字符串（节省空间），只需注意长度的缩减。
   * 第 i 次循环后，字符串长度变为 `n - i`。

3. **结束条件与判断**

   * 循环结束后，字符串中只剩两个字符。
   * 直接比较 `s[0]` 和 `s[1]` 是否相等：

     * 若相等，返回 `true`；
     * 否则返回 `false`。

---

## 🧮 示例解析

### 示例 1：

输入：`s = "3902"`

执行过程如下：

| 步骤  | 操作结果    | 计算说明                               |
| --- | ------- | ---------------------------------- |
| 初始  | 3 9 0 2 | —                                  |
| 第1次 | 2 9 2   | (3+9)%10=2, (9+0)%10=9, (0+2)%10=2 |
| 第2次 | 1 1     | (2+9)%10=1, (9+2)%10=1             |

最终结果 `"11"` → 两个数字相等 → ✅ 返回 `true`。

---

### 示例 2：

输入：`s = "34789"`

执行过程：

| 步骤  | 操作结果      |
| --- | --------- |
| 初始  | 3 4 7 8 9 |
| 第1次 | 7 1 5 7   |
| 第2次 | 8 6 2     |
| 第3次 | 4 8       |

最终 `"48"` → 两个数字不相等 → ❌ 返回 `false`。

---

## 🧠 复杂度分析

* **时间复杂度**：O(n²)
  因为第一层计算 n−1 次，第二层 n−2 次，以此类推，总操作次数为：
  [
  (n-1) + (n-2) + ... + 1 = O(n^2)
  ]
  但由于 n ≤ 100（题目限制），完全可接受。

* **空间复杂度**：O(1)
  在原字符串上进行原地更新，没有使用额外空间。

---

## ✅ 总结

这是一道典型的**模拟迭代题**。
思路关键点如下：

1. 每一轮计算相邻数字的“模10和”；
2. 原地更新字符串；
3. 迭代 n−2 次；
4. 最后判断剩下的两个字符是否相同。

该算法简单直观，直接反映题目定义的操作规则。

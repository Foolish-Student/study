# 3494.酿造药水需要的最少总时间

## 题目

* 有 `n` 个巫师（工序 0…n-1），要按既定顺序依次处理 `m` 个药水（作业 0…m-1）。
* 第 `i` 个巫师在第 `j` 个药水上的处理时间：`p[i][j] = skill[i] * mana[j]`。
* **无等待约束（No-Wait）**：某药水在巫师 `i` 完成后，**必须立刻转交**给巫师 `i+1` 并马上开始，不允许在工序之间“卡住等待”。
* 同一巫师**不能并行**，前一瓶没做完就不能开下一瓶。

目标：最小化完成所有药水的**总时间**（最后一个巫师处理完最后一瓶的时刻）。

---

## 建模与关键观察

这其实是**固定作业顺序**的“**无等待流水线（no-wait flow shop）**”问题：

* 把每瓶药水看作**一段连续不被切断**的加工链：在工序 `0 → 1 → … → n-1` 上**不允许空隙**。
* 不同药水在同一巫师上是**串行**的，不能重叠。
* 因此，在安排第 `j` 瓶时，**整条链**可能需要被**整体推迟**，以满足所有巫师的“机器空闲”约束，并同时保持“工序间无等待”。

---

## 核心思路（一次处理一瓶，沿着整条流水线“推着走”）

### 状态定义

* `last[i]`：在处理第 `j` 瓶之前，巫师 `i` 的**最早可用时间**（等价于他完成第 `j-1` 瓶的时间）。
* `cur`：当前这瓶药水沿着流水线**推进到的“结束时刻”**（初始为 0）。

### 处理第 `j` 瓶的推进规则

对工序 `i = 0..n-1` 依次执行：

1. 这瓶在巫师 `i` 的**开工时刻**
   `start[i][j] = max(cur, last[i])`
   解释：

   * `cur` 是**上一道工序**（`i-1`）刚完成这瓶的时刻（保证**无等待**）。
   * `last[i]` 是巫师 `i` 上一瓶的完成时刻（保证**不重叠**）。
   * 若 `last[i]` 更大，说明机器 `i` 还没空，则**必须整体推迟**整条链，`start[i][j]` 取更大者。
2. **完成时刻**
   `finish[i][j] = start[i][j] + p[i][j]`
3. 推进“前沿”
   `cur = finish[i][j]`

循环完 `i = 0..n-1` 后，`cur` 就是这瓶在最后一个巫师处的完成时刻，也就是目前的“总工期”新值。

### 为什么还要“回填”各巫师的完成时刻？

下一瓶也要用到每个巫师的“最早可用时间”：

* 我们已经得到这瓶的 `finish[n-1][j] = cur`。由于**无等待**，这瓶在各工序上的时间段**首尾紧贴**，因此可以从后往前把每个巫师的完成时刻“切出来”：

  ```
  finish[n-1][j] = cur
  finish[i][j]   = finish[i+1][j] - p[i+1][j]      （i = n-2..0）
  ```
* 然后令 `last[i] = finish[i][j]`，作为下一瓶的“机器可用时间”。

> 直觉：这一步就是把“整条连续时间段”按各工序的加工时长一段段切开，得到每位巫师**恰好在这瓶上的结束时刻**，供下一瓶参考。

---

## 正确性小证明（不变式）

* 不变式：在处理第 `j` 瓶之前，`last[i]` 等于巫师 `i` 完成第 `j-1` 瓶的时刻。
* 处理第 `j` 瓶时，`start[i][j] = max(cur, last[i])` **同时**满足：

  * 与工序 `i-1` 的无等待拼接（`cur`）；
  * 与该巫师自身的串行占用（`last[i]`）。
    若 `last[i]` 限制更紧，则“整体推迟”整条链（体现为 `max`）。
* 完成后，回填出的 `finish[i][j]` 更新为新的 `last[i]`，不变式对第 `j+1` 瓶继续成立。归纳得证。

---

## 示例走一遍（样例 1 的前两瓶，简要）

`skill=[1,5,2,4]`，`mana=[5,1,4,2]`
第一瓶 `mana=5`，时长 `p=[5,25,10,20]`，初始 `last=[0,0,0,0]`：

* 逐工序推进：完成时刻得到 `[5,30,40,60]`，`cur=60`
* 回填更新 `last=[5,30,40,60]`

第二瓶 `mana=1`，`p=[1,5,2,4]`，当前 `last=[5,30,40,60]`：

* 逐工序推进，因机器空闲限制，链条被整体推迟，最终完成时刻为 `[53,58,60,64]`，`cur=64`
* 回填更新 `last=[53,58,60,64]`

继续对第三、四瓶同理推进，即可得到题面表格中的时间轴，最后的 `cur` 就是答案 `110`。

---

## 复杂度

* 外层遍历 `m` 瓶药水，内层每瓶推进 `n` 道工序并一次回填 `O(n)`。
* **时间复杂度**：`O(n * m)`
* **空间复杂度**：`O(n)`（只需维护 `last`；若实现时临时回填可就地写回）

> 实现时注意乘法用 64 位整型（`long long`）避免溢出：`skill[i]*mana[j]` 可能超出 32 位。

---

## 结论

将问题视作“**固定顺序的无等待流水线**”，对每瓶药水**沿着工序从左到右**一次推进，遇到任一巫师尚未空闲就**整体推迟**，确保工序间**零等待**；随后**回填**各巫师的完成时刻作为下一瓶的“可用时间”。这个模拟既满足约束，又实现了全局最早完成，最终 `cur`（或等价的 `last[n-1]`）即为最短总时间。

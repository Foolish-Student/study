# 🧩 可被 5 整除的二进制前缀（1018）

## 🔍 问题描述

给定一个二进制数组 `nums`，我们依次把它的前缀看作一个二进制数：

* `xi` = 由 `nums[0..i]` 组成的二进制数
* 判断 `xi` 是否能被 5 整除

要返回一个布尔数组 `answer`，表示每个前缀是否可被 5 整除。

---

# 💡 核心思路：只需要维护前缀 mod 5

直接把前缀当成二进制转换成十进制会非常大（最长 10⁵ 位），但题目只问是否**能被 5 整除**，我们可以从数学性质出发：

对于任何数字：

```
new_x = old_x * 2 + nums[i]
```

我们只关心它是否 mod 5 == 0，因此可以每一步都取模：

```
new_mod = (old_mod * 2 + nums[i]) % 5
```

这样：

* 永远不会溢出
* 只保存 mod 5 的值（0~4）
* 每步 O(1) 复杂度，总复杂度 O(n)

当 `new_mod == 0` 时表示当前前缀可被 5 整除。

---

# 🧠 为什么取模不会影响结果？

因为：

> 若 a ≡ b (mod 5)，则 a 和 b 是否能被 5 整除具有相同结果。

保持 mod 5 足以判断可整除性。

---

# ✔ 示例解释

### 示例 1

```
nums = [0,1,1]
前缀二进制： 0 → 01 → 011
十进制：       0 → 1 → 3
```

能被 5 整除的只有 0 → 返回：

```
[true, false, false]
```

---

# ⏱ 复杂度分析

* **时间复杂度：O(n)**
* **空间复杂度：O(n)** 返回结果数组大小为 n

---

# 🎯 总结

本题的关键技巧是：

> 使用「前缀滚动计算 + 取模」，避免处理大整数。

每步只需更新一个 mod 值即可判断当前前缀是否能被 5 整除。

整个过程既高效又安全，是二进制前缀类题目的典型技巧。

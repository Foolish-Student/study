# 3186. 施咒的最大总伤害｜题解（值域压缩 + “带空档”的选择型 DP）

## 一、题意拆解

* 有若干咒语，伤害值 `power[i]` 可重复。
* 一旦使用伤害为 `x` 的咒语，就**不能**再用伤害为 `x-2, x-1, x+1, x+2` 的咒语。
* 每个具体咒语最多用一次，但**同伤害值之间并不互斥**（限制只排斥±1、±2，不排斥相等）。
* 目标：最大化选取咒语的伤害和。

关键洞察：如果我们决定“选用伤害值 `x` 这一档的咒语”，那显然应该把该档的**全部个数**都选上（因为相同伤害值之间不冲突，且每个只能用一次），贡献就是
**`x * cnt[x]`**。

因此问题化为：从若干“伤害值档位”中选一些档位，使得任意两个被选档位的数值差**至少为 3**（排除 ±1、±2），总收益（`x * cnt[x]`）最大。

这和经典的「Delete and Earn」很像，但不是禁相邻 1，而是禁距离 ≤ 2。

---

## 二、值域压缩：把“多咒语同值”合并成“加权点”

1. 统计每个伤害值 `x` 的出现次数 `cnt[x]`。
2. 收集所有不同的伤害值并排序得到数组 `v = sorted(unique(power))`。
3. 每个 `v[i]` 的收益权重 `w[i] = v[i] * cnt[v[i]]`。

这样，问题变成：在**有序数轴**上的若干点（`v[i]`），选择一些点，使任意两个被选点的差 ≥ 3，且总权重和最大。

---

## 三、动态规划建模（带空档的“选或不选”）

令 `dp[i]` 表示“考虑前 `i` 个不同伤害值（`v[0..i-1]`），能达到的最大总伤害”。
转移时考察第 `i` 个值（下标从 1 开始叙述方便）：

* **不选 `v[i-1]`**：`dp[i] = dp[i-1]`
* **选 `v[i-1]`**：必须保证此前选择的最大值 ≤ `v[i-1] - 3`
  设 `j` 为**满足** `v[j] < v[i-1] - 2` 的**最后一个下标 + 1**（也就是第一个不冲突的前缀长度），则
  `dp[i] = dp[j] + w[i-1]`

取两者最大：

> **`dp[i] = max(dp[i-1], dp[j] + v[i-1] * cnt[v[i-1]])`**

如何快速找到 `j`？
由于 `v` 已排序，且 `i` 递增，我们可以用**双指针**维护一个指针 `j`，使得始终有：

```
v[0..j-1] < v[i-1] - 2   且   v[j] >= v[i-1] - 2
```

于是选 `v[i-1]` 时，合法搭配的最佳值为 `dp[j]`。

> 直观理解：选了 `v[i-1]`，就必须与所有在区间 `[v[i-1]-2, v[i-1]-1]` 的值断开；
> 因为 `v` 升序，所以能配的只有严格小于 `v[i-1]-2` 的那些值，它们的最优正是 `dp[j]`。

---

## 四、流程小结

1. 统计频次 `cnt`，把不同值收集成有序数组 `v`；
2. 设 `w[i] = v[i] * cnt[v[i]]`；
3. 用 `dp[0..|v|]`，`dp[0]=0`；
4. 双指针推进 `i` 和 `j`：

   * `i` 从 1 到 `|v|`：

     * 相应地右移 `j`，直到 `v[j] >= v[i-1] - 2`（**即** `v[0..j-1] < v[i-1]-2`）；
     * `dp[i] = max(dp[i-1], dp[j] + w[i-1])`。
5. 答案为 `dp[|v|]`。

---

## 五、正确性要点

* **为什么可把同值全取？** 约束只排斥 `±1`、`±2`，同值之间不冲突，且每个只能用一次——因此若决定使用该值档，选得越多越好，直接一次性取完收益最大。
* **为什么只看差 ≥ 3？** 题目禁止 `x±1`、`x±2`，等价于两被选值的差不得落在 `{1,2}`，所以最小合法差是 3。
* **双指针找 `j` 正确吗？** 因为 `v` 升序、`i` 增大时阈值 `v[i-1]-2` 增大，满足条件的前缀只会**右移**，`j` 单调不回退。

---

## 六、复杂度分析

* 统计频次 `O(n)`；收集并排序不同值 `O(U log U)`，`U` 为不同伤害值个数（`U ≤ n`）。
* DP 主循环 `O(U)`；双指针总移动 `O(U)`。
* 总时间 `O(n + U log U)`，空间 `O(U)`。
* 由于伤害值最大可达 `1e9`、次数可达 `1e5`，最终答案最大约 `1e14`，需用 64 位整型（`long long`）。

---

## 七、示例走一遍

### 示例一

`power = [1,1,3,4]`

* 计数：`cnt[1]=2, cnt[3]=1, cnt[4]=1`
* `v = [1,3,4]`，`w = [2, 3, 4]`。
* 选 4 时不能选 2/3/5/6，其中 3 受限，1 允许（差 3），但 1 的值与 4 不冲突？差为 3，合法。
  然而由于 `v` 中没有 2，`j` 会正确停在 1（对应只考虑 `1` 的最优），最后给出最优：取 `1,1,4` 得 6。

### 示例二

`power = [7,1,6,6]`

* 计数：`cnt[1]=1, cnt[6]=2, cnt[7]=1`
* `v=[1,6,7]`，`w=[1,12,7]`
* 选 6 后不能选 4/5/7/8，所以 7 被禁；1 可以和 6 同时选（差 5）。
* 最优为 `1 + 6 + 6 = 13`。

---

## 八、总结

* 把“选择具体咒语”转化为“选择值档位”，每档收益为 `值 × 个数`。
* 排斥关系变成“选点之间差 ≥ 3”的**带空档的选择型 DP**。
* 按值域压缩 + 排序 + 双指针找前一个可兼容位置，转移 **`dp[i] = max(dp[i-1], dp[j] + w[i-1])`**。
* 复杂度优雅、实现稳健，满足大范围与大数值的要求。

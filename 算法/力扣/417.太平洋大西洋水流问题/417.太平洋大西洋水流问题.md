# 417.太平洋大西洋水流问题

## 🌊 题目理解

题目描述了一个岛屿的地形，用一个二维矩阵 `heights[m][n]` 表示每个位置的海拔高度。
岛的左边界和上边界是 **太平洋（Pacific）**，右边界和下边界是 **大西洋（Atlantic）**。

水流的规则是：

* 水只能从当前格子 **流向相邻（上下左右）且高度不大于当前格子** 的位置。
* 也就是说：**水只能从高处流向低处或等高处。**

题目要求找出所有既能流入太平洋、又能流入大西洋的坐标。

---

## 💡 思路分析

### **1. 直接模拟的想法（从每个格子出发）**

最初我们可能会想到：

* 对于每个格子 `(i, j)`，从它出发，向四个方向搜索，看是否能流到太平洋和大西洋。

但是这样做的时间复杂度非常高：

* 每个格子都要做一次 DFS/BFS，且每次都可能遍历整个地图。
* 时间复杂度约为 (O(m \times n \times m \times n))，会超时（最大 200×200 = 4万格）。

所以我们需要**反过来思考**。

---

### **2. 反向思考（从海洋出发）**

我们不从每个格子出发看“水能不能流到海洋”，
而是**从海洋边界出发**，看“哪些格子能流到这里”。

也就是说：

* 从**太平洋边界（上边界 + 左边界）**出发，
  向内陆反向搜索，记录所有可以流入太平洋的格子。

* 从**大西洋边界（下边界 + 右边界）**出发，
  向内陆反向搜索，记录所有可以流入大西洋的格子。

这种“反向搜索”其实是在模拟：

> 哪些格子能“让水流下来到海洋”，等价于“哪些格子能被海洋水倒着流上去”。

---

### **3. 反向搜索的逻辑**

在正向模拟中，水从高处流向低处：

```
当前格子高度 ≥ 相邻格子高度
```

而在反向搜索中，方向相反，我们从海洋往高处走：

```
相邻格子高度 ≥ 当前格子高度
```

也就是说：

* 反向搜索时，只能从低处流向高处或等高处。
* 每次都保证当前路径是合法的“倒流”路径。

---

### **4. 搜索实现方式**

无论是 DFS 还是 BFS 都可以实现反向搜索。
这里常用的是 BFS（你代码里用的正是 BFS）。

搜索过程如下：

1. **初始化两个访问矩阵**：

   * `pacific[m][n]`：标记能到达太平洋的格子；
   * `atlantic[m][n]`：标记能到达大西洋的格子。

2. **从边界入队**：

   * 太平洋的入口：上边界（row=0）+ 左边界（col=0）
   * 大西洋的入口：下边界（row=m-1）+ 右边界（col=n-1）

3. **进行 BFS / DFS**：

   * 从当前海洋边界的所有格子出发；
   * 对每个相邻的格子 `(nx, ny)`，如果：

     * 没有访问过；
     * 且 `heights[nx][ny] >= heights[x][y]`；
     * 就可以“反向流过去”，继续搜索。

4. **标记访问过的格子**：

   * 对于太平洋，从太平洋边界开始标记；
   * 对于大西洋，从大西洋边界开始标记。

---

### **5. 合并结果**

经过两次搜索，我们就得到了：

* 所有能流到太平洋的格子；
* 所有能流到大西洋的格子。

只需要遍历整个矩阵：

* 如果某个格子在两个访问矩阵中都为 `true`，
  那它就是可以同时流向两个海洋的格子。

---

### **6. 时间复杂度分析**

* 每个格子最多被访问两次（一次在太平洋搜索中，一次在大西洋搜索中）。
* 每次访问最多检查四个方向。
* 所以总复杂度为：
  [
  O(m \times n)
  ]
* 空间复杂度也是 (O(m \times n))，用于标记访问状态。

---

## 🌍 举例理解

以示例输入：

```
heights = [
 [1, 2, 2, 3, 5],
 [3, 2, 3, 4, 4],
 [2, 4, 5, 3, 1],
 [6, 7, 1, 4, 5],
 [5, 1, 1, 2, 4]
]
```

### 太平洋边界：

* 上边界（row = 0）
* 左边界（col = 0）

从这些格子出发，按照“反向能流到高处”的规则，BFS 向内扩散。

得到的结果区域：

```
能到太平洋的格子：
[0,0], [0,1], [0,2], [0,3], [0,4],
[1,0], [1,1], [1,2], [1,3],
[2,0], [2,1], [2,2],
[3,0], [3,1],
[4,0]
```

### 大西洋边界：

* 下边界（row = m - 1）
* 右边界（col = n - 1）

从这些格子出发反向搜索，得到：

```
能到大西洋的格子：
[4,4], [3,4], [2,2], [1,3], [0,4], ...
```

两者的交集就是结果：

```
[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

---

## ✅ 总结

| 思路步骤     | 说明                       |
| -------- | ------------------------ |
| 1️⃣ 问题转化 | 不从每格出发，而是从海洋反向搜索         |
| 2️⃣ 双边搜索 | 从太平洋边界和大西洋边界分别进行 BFS/DFS |
| 3️⃣ 搜索条件 | 只从低处走到相邻高处或等高处           |
| 4️⃣ 合并结果 | 同时能被两种海洋访问的格子            |
| 5️⃣ 复杂度  | O(m×n)，空间 O(m×n)         |

---

### 💬 一句话总结：

> 从两个海洋“反向上溯”，找出哪些格子能被两种海洋都到达。
> 这样避免重复搜索，既高效又直观。

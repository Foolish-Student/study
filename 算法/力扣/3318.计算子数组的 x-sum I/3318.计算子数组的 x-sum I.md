# 3318.计算子数组的 x-sum I
## 题目：
给定一个整数数组 `nums`，以及整数 `k` 和 `x`。
要求对于每个长度为 `k` 的子数组，计算其“x-sum”值。
x-sum 的定义如下：

1. 统计子数组中所有元素的出现次数；
2. 仅保留出现次数最多的前 `x` 种元素（若频率相同，则保留数值较大的元素）；
3. 计算保留元素的总和（包括它们的所有出现次数）；
4. 若子数组中不同元素数量小于 `x`，则直接取整个子数组的总和。

最后返回每个子数组的 x-sum 结果。

---

## 🧩 思路分析

1. **核心问题：**
   对于每个长度为 `k` 的滑动窗口，统计出现次数最多的 `x` 个元素，并计算这些元素在子数组中的贡献和。
   由于每个子数组都相对独立，可以直接暴力计算每个窗口内的频率分布。

---

2. **数据结构选择：**
   使用 `map<int, int, greater<int>>`（即按元素值从大到小排序的有序映射）：

   * `key` 为元素值；
   * `value` 为该元素在当前窗口的出现次数；
   * 通过 `greater<int>` 使得当出现次数相同时，优先选择数值更大的元素（题目要求）。

---

3. **算法流程：**

   对于每个起点 `i`（从 `0` 到 `n - k`）：

   1️⃣ **构建频率映射**
   遍历子数组 `nums[i..i+k-1]`，统计每个数字出现次数。

   2️⃣ **选择出现次数最多的前 x 个元素**

   * 若当前子数组中不同元素数量少于 `x`，说明无需筛选，直接求子数组总和；
   * 否则：

     * 重复执行 `x` 次：

       * 找出当前频率最高的元素（若并列，则取值更大的那个）；
       * 将它的所有出现次数乘以该数值，加入总和；
       * 删除该元素，以便选取下一个。

   3️⃣ **存入结果**
   将计算出的 x-sum 结果添加到 `res` 数组中。

---

4. **辅助函数 `getMaxFrequency()`：**

   * 遍历整个 `map`；
   * 记录频率最高的元素；
   * 若频率相同，则保留值较大的元素；
   * 返回该元素的数值。

---

## 🧮 示例分析

### 示例 1

```
nums = [1,1,2,2,3,4,2,3]
k = 6, x = 2
```

| 子数组范围 | 内容            | 前x高频元素       | x-sum计算      | 结果 |
| ----- | ------------- | ------------ | ------------ | -- |
| [0,5] | [1,1,2,2,3,4] | 1(2次), 2(2次) | 1+1+2+2=6    | 6  |
| [1,6] | [1,2,2,3,4,2] | 2(3次), 4(1次) | 2+2+2+4=10   | 10 |
| [2,7] | [2,2,3,4,2,3] | 2(3次), 3(2次) | 2+2+2+3+3=12 | 12 |

✅ 输出：`[6,10,12]`

---

### 示例 2

```
nums = [3,8,7,8,7,5]
k = 2, x = 2
```

由于 `k == x`，每个子数组的不同元素数 ≤ x，因此每次的 x-sum 就是子数组的总和：

| 子数组   | 元素     | 和  |
| ----- | ------ | -- |
| [3,8] | 3+8=11 | 11 |
| [8,7] | 8+7=15 | 15 |
| [7,8] | 7+8=15 | 15 |
| [8,7] | 8+7=15 | 15 |
| [7,5] | 7+5=12 | 12 |

✅ 输出：`[11,15,15,15,12]`

---

## 🧠 复杂度分析

* **时间复杂度：**
  对于每个窗口（共 n-k+1 个），需要统计频率并寻找前 x 个元素：
  `O((n-k+1) * k)`，在题目约束 `n ≤ 50` 下完全可行。

* **空间复杂度：**
  `O(k)` — 存储当前窗口的频率映射。

---

## ✅ 总结

这道题的关键在于：

1. 理解 **“出现次数最多 + 值更大优先”** 的优先规则；
2. 使用 `map<int,int,greater<int>>` 有效实现有序统计；
3. 通过辅助函数获取最高频元素；
4. 采用分段遍历的方式计算每个窗口的 x-sum。

整体算法思路清晰、实现简洁，非常适合用于小规模窗口统计类问题。

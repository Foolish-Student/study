# 3147.从魔法师身上吸取的最大能量

## 题目

* 站成一排的 `n` 个魔法师，能量数组 `energy` 可正可负。
* 吸收规则：从某个下标 `i` 开始，每次跳到 `i + k`，直到越界为止；沿途把经过的能量累加。
* 目标：选择**起点**使得总能量最大。

---

## 一眼看破：把数组按“模 k”分成 k 条独立链

固定 `k` 后，按下标对 `k` 取模，可把所有位置分成 `k` 条**不相交的链**：

* 第 `r` 条链（`r=0..k-1`）：`r, r+k, r+2k, ...`（直到 < `n` 的最大下标）
* 从任意位置出发，之后的跳跃都在**同一条链**上向右走，直至该链的末尾。

因此，**从该链的任意位置出发累加到链末尾**，其实就是这条链的某个**后缀和**。
整题就等价于：**对每条链，取“最大后缀和”，再在所有链里取最大值**。

> 为什么是“后缀和”？因为你一旦选了起点，就必须一路跳到链的末尾，不能提前停，也不能跨到别的链。

---

## 关键观察：最末端一定在最后 `k` 个下标中

每条链的**末尾**一定是某个下标 `i`，满足 `i ∈ [n-k, n-1]`。
也就是说，**每条链都对应着最后 `k` 个下标里的一个“链尾”**。

---

## 算法思路（与你代码一致）

1. **枚举链尾**：遍历 `i = n-k, n-k+1, ..., n-1`。每个 `i` 恰好对应一条模 `k` 的链。
2. **沿链反向累加**：从 `j = i` 开始，按步长 `k` 逆向走 `j -= k`，一路做前缀（对反向而言）累加：

   * `tempSum += energy[j]`，把从 `j` 出发到链尾 `i` 的和算出来。
   * 用一个全局 `answer` 维护所有链、所有起点的**最大后缀和**。
3. **返回答案**。

这个做法恰好**对每条链只扫描一次**：因为链尾唯一，即 `i` 正好选到了该链的最后一个下标。总体时间是 `O(n)`，额外空间 `O(1)`。

---

## 正确性说明

* **必要性**：选定起点后，跳跃步长固定为 `k`，因此路径被限定在某条“模 `k` 链”上；到达链尾即停止，故路径和必是该链的一个后缀和。
* **充分性**：枚举所有链尾，并沿链逆向枚举所有可能起点，等价于枚举了所有可能的“起点→链尾”的路径，取其最大值即为全局最优。
* **不重不漏**：`i ∈ [n-k, n-1]` 恰好覆盖每条链的末尾一次；链上每个位置 `j` 恰好在其所属的链的逆向扫描中被访问一次，因此没有重复计算，也不遗漏。

---

## 复杂度分析

* **时间**：`O(n)`（`k` 条链总长度为 `n`）
* **空间**：`O(1)`（只需若干标量变量）
* 注：`|energy[i]| ≤ 1000`、`n ≤ 1e5`，总和上界约 `1e8`，`int` 足够（C++ 里无需特意换 `long long`）。

---

## 样例推演

### 示例一

`energy = [5, 2, -10, -5, 1], k = 3`
链划分：

* `r=0` 链：`[0, 3] → [5, -5]`，后缀和最大为 `max( -5, 5 + (-5)=0 ) = 0`
* `r=1` 链：`[1, 4] → [2, 1]`，后缀和最大为 `max( 1, 2+1=3 ) = 3`
* `r=2` 链：`[2] → [-10]`，最大为 `-10`
  取三条链的最大值 `max(0, 3, -10) = 3`（与答案一致）。

### 示例二

`energy = [-2, -3, -1], k = 2`
链划分：

* `r=0` 链：`[0, 2] → [-2, -1]`，最大后缀和为 `max(-1, -2 + -1 = -3) = -1`
* `r=1` 链：`[1] → [-3]`，最大为 `-3`
  取最大为 `-1`（与答案一致）。

---

## 边界与细节

* **全部为负**：算法会自然地选到某条链中的**最“没那么负”的单点**作为后缀（即最大后缀和），是正确的。
* **`k = n-1`**：只有两条链，扫描同样成立。
* **只需最后 `k` 个下标作为链尾**：这是“停止条件”决定的，不会错过任何可能路径。

---

## 小结

* 把数组按 `mod k` 切成 `k` 条链；答案就是**各链的最大后缀和**中的最大者。
* 实现上，从**最后 `k` 个位置**出发，按步长 `k` 向左累加即可，**一次扫描 `O(n)`** 得到答案。

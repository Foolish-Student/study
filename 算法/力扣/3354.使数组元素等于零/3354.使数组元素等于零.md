# 3354.使数组元素等于零
## 题目
给定一个整数数组 `nums`，初始时选择一个位置 `curr`，要求 `nums[curr] == 0`，并选择一个移动方向（左或右）。
之后反复执行如下操作：

1. 若 `curr` 越界，过程结束。
2. 若 `nums[curr] == 0`，继续沿当前方向移动；
3. 若 `nums[curr] > 0`，则将该位置减 1，并反转方向，然后沿新方向移动一步。
   最终若能使所有元素都变为 0，则该初始位置与方向为**有效方案**。
   返回所有可能的有效方案数量。

---

## 🧩 思路分析

1. **明确问题本质：**

   * 本题模拟一个“反复反弹”的过程：
     从一个 0 元素开始，沿某方向移动；
     遇到非零元素就削减它（减 1），再反转方向继续移动。
   * 目标是判断哪些起点和方向可以最终让所有元素归零。

2. **整体思路：暴力枚举 + 模拟过程**

   * 遍历数组中所有 `nums[i] == 0` 的位置；
   * 对于每个这样的起点 `i`，尝试：

     * 向左移动 (`dir = -1`)；
     * 向右移动 (`dir = +1`)；
   * 分别判断这两种情况是否能使整个数组归零。

3. **模拟函数逻辑（`isValid` 的核心思路）**

   * 创建一个 `temp` 数组（复制 `nums`），用于模拟减少操作；
   * 记录当前非零元素数量 `noZeros`；
   * 从 `start` 位置开始，按当前方向移动，执行以下循环：

     1. 若越界或所有元素都为 0，则结束；
     2. 若当前位置大于 0：

        * 执行 `temp[curr] -= 1`；
        * 若减到 0，则非零计数减一；
        * 反转方向；
        * 移动到下一位置；
     3. 若当前位置等于 0，直接按当前方向继续前进。
   * 若循环结束时 `noZeros == 0`，说明该起点与方向能使数组全归零。

4. **计数逻辑**

   * 对每个起点 `i`（满足 `nums[i] == 0`）：

     * 如果向左有效，则方案数 +1；
     * 如果向右有效，则方案数 +1；
   * 最终返回总数。

---

## 🧮 示例解析

### 示例 1：

```
nums = [1, 0, 2, 0, 3]
```

* 共有两个位置为 0：`nums[1]` 和 `nums[3]`。
* 从 `i = 1` 开始：

  * 向左模拟失败（最左端 1 无法被削成 0）；
  * 向右模拟失败（3 太远无法被削成 0）。
* 从 `i = 3` 开始：

  * 向左：成功（整个数组最终变为 [0,0,0,0,0]）；
  * 向右：成功（同样可归零）。
* 因此共有 **2 种有效方案**。

---

### 示例 2：

```
nums = [2, 3, 4, 0, 4, 1, 0]
```

* 共有两个位置为 0：`nums[3]` 和 `nums[6]`；
* 无论从哪个起点出发，模拟后都无法让前面的高位完全清零；
* 因此输出 **0**。

---

## 🧠 复杂度分析

* **时间复杂度**：O(n²)
  每个零元素作为起点，最坏情况需要遍历整个数组一次。
* **空间复杂度**：O(n)
  需要复制数组进行模拟。

---

## ✅ 总结

这是一道典型的**模拟与暴力搜索**结合题。
关键点在于：

1. 从所有零元素开始枚举；
2. 按规则反复模拟“削减 + 反向移动”的过程；
3. 检查最终是否能归零。

该方法直观易理解，数据范围较小（n ≤ 100），完全可以通过暴力模拟得出正确结果。

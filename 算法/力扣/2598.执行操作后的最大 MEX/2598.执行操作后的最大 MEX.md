# 2598.执行操作后的最大 MEX


## 一、题目描述

给定一个整数数组 `nums` 和一个整数 `value`。

你可以对数组中任意元素执行任意次以下操作：

> 将某个元素加上或减去 `value`。

执行任意次操作后，定义数组的 **MEX**（Minimum Excluded Number）为数组中缺失的最小非负整数。
题目要求返回通过任意操作后，数组 `nums` 的 **最大可能 MEX**。

---

### ✅ 示例 1

```
输入：
nums = [1, -10, 7, 13, 6, 8]
value = 5

输出：
4
```

**解释：**

* 经过多次加减操作后可以得到 `[1, 0, 2, 3, 6, 8]`
* 缺失的最小非负整数是 `4`
* 因此最大 MEX = 4

---

### ✅ 示例 2

```
输入：
nums = [1, -10, 7, 13, 6, 8]
value = 7

输出：
2
```

**解释：**

* 通过适当加减操作可以得到 `[1, 0, 7, 13, 6, 8]`
* 数组中包含 `0, 1`，但缺少 `2`
* 最大 MEX = 2

---

## 二、思路分析

### 1️⃣ 关键观察：同余类不变

由于你只能对每个数加或减若干次 `value`：

[
x \to x + k \times value
]

这意味着每个数都只能停留在 **模 value 同余的类中**。

例如：

* 若 `value = 5`，则
  数 `1` 可以变成 `…, -9, -4, 1, 6, 11, 16, …`
  它们的模 5 余数都等于 1。

👉 所以每个数的“余数类”固定不变，而你能控制的只是每类中数字出现的次数。

---

### 2️⃣ 把问题转化为“余数计数”

目标是让数组中包含 `0, 1, 2, 3, …` 这些非负整数连续存在，以让 MEX 尽量大。

* 若想“造出”数字 `x`，你需要有一个数属于余数类 `x % value`。
* 并且每造出一个数字，就会消耗一个该余数类的元素。

于是，问题可以转化为：

> 从 `mex = 0` 开始，每次查看余数类 `mex % value` 是否还有库存；
> 有 → 消耗一个 → `mex++`；
> 无 → 停止；
> 停止时的 `mex` 就是最大 MEX。

---

### 3️⃣ 例子演示

以 `nums = [1, -10, 7, 13, 6, 8], value = 5` 为例。

#### 步骤 ①：计算余数

取模时记得处理负数：

[
(x % value + value) % value
]

得到余数序列：

```
[1, 0, 2, 3, 1, 3]
```

统计频次：

```
余数 0：1 个
余数 1：2 个
余数 2：1 个
余数 3：2 个
余数 4：0 个
```

#### 步骤 ②：从 0 开始模拟造数

| 目标数 | 需要余数类 | 库存是否有 | 动作   | 更新后库存    |
| --- | ----- | ----- | ---- | -------- |
| 0   | 0     | ✅ 有   | 消耗一个 | cnt[0]=0 |
| 1   | 1     | ✅ 有   | 消耗一个 | cnt[1]=1 |
| 2   | 2     | ✅ 有   | 消耗一个 | cnt[2]=0 |
| 3   | 3     | ✅ 有   | 消耗一个 | cnt[3]=1 |
| 4   | 4     | ❌ 无   | 停止   | —        |

停止时，`mex = 4`。
即最大 MEX = **4**。

---

## 三、算法步骤

1. **构建频次数组**

   ```cpp
   vector<int> cnt(value, 0);
   for (x : nums)
       cnt[(x % value + value) % value]++;
   ```

2. **贪心推进 mex**

   ```cpp
   int mex = 0;
   while (cnt[mex % value] > 0) {
       cnt[mex % value]--;
       mex++;
   }
   ```

3. **返回结果**

   ```cpp
   return mex;
   ```

---

## 四、复杂度分析

| 指标    | 复杂度                            |
| ----- | ------------------------------ |
| 时间复杂度 | **O(n)**，遍历 `nums` 一次 + 贪心循环一次 |
| 空间复杂度 | **O(value)**，存储 `value` 个余数类计数 |

---

## 五、总结

| 关键点  | 含义                 |
| ---- | ------------------ |
| 操作本质 | 只能在同一个余数类中移动       |
| 解决思路 | 统计余数类数量，逐步消耗模拟 MEX |
| 核心算法 | 模取余 + 贪心           |
| 复杂度  | 线性 O(n)            |

**一句话总结：**

> 把所有数字按 `value` 取模分组统计，从 `mex=0` 开始逐步尝试“用库存造数”，能造则消耗，不能造则停止，停止时的 `mex` 即最大 MEX。

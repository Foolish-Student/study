# 3228.将 1 移动到末尾的最大操作次数
## 题目
给定一个二进制字符串 `s`，你可以多次执行以下操作：
选择任意下标 `i`（满足 `s[i] == '1'` 且 `s[i+1] == '0'`），
将该 `'1'` 向右移动，直到遇到另一个 `'1'` 或到达字符串末尾。
要求返回最多能执行多少次这样的操作。

---

## 🧩 思路分析

这道题的关键在于**统计“1”在遇到“0”时能产生多少次有效移动**。
每次操作的实质是让一个 `'1'` 越过若干个 `'0'`，并逐步被“锁定”在末尾的 `'1'` 区域中。

换句话说，每当有一个 `'1'` 紧挨着 `'0'`（形成 `'10'` 模式）时，这个 `'1'` 有机会右移，而右移次数受到它左侧已经出现的 `'1'` 数量影响。

---

### 1️⃣ 操作规律

从左到右遍历字符串时：

* 当遇到 `'1'`，表示可以增加一个“可移动的 1”；
* 当遇到 `'0'`，并且它的左边是 `'1'` 时，说明存在一个 `'10'` 对；

  * 此时所有在这之前出现过的 `'1'` 都可能参与一次移动；
  * 因此，操作次数增加当前已出现 `'1'` 的数量。

这样每个 `'10'` 的出现，就贡献出一次“将左侧所有1向右推”的机会。

---

### 2️⃣ 累积思想解释

例如：

```
s = "1001101"
```

逐位分析：

| 位置 | 字符 | 累计 1 的数量 | 贡献操作次数 | 累积总操作数 |
| -- | -- | -------- | ------ | ------ |
| 0  | 1  | 1        | -      | 0      |
| 1  | 0  | 1        | +1     | 1      |
| 2  | 0  | 1        | 0      | 1      |
| 3  | 1  | 2        | -      | 1      |
| 4  | 1  | 3        | -      | 1      |
| 5  | 0  | 3        | +3     | 4      |
| 6  | 1  | 4        | -      | 4      |

最终结果 = 4。
这恰好对应题目样例的最大操作次数。

---

### 3️⃣ 直观理解

可以把 `'1'` 看作“可右移的单位”，而 `'0'` 是“可让位的位置”。
每当 `'10'` 出现时，当前这个 `'0'` 可以让之前的所有 `'1'` 向右多移动一步。
因此，每个 `'10'` 都会产生 `当前累计的 1 的数量` 次贡献。

---

## 🧮 示例分析

### 示例 1：

```
输入：s = "1001101"
输出：4
```

* 第 1 个 `'10'`：贡献 1；
* 第 5 个 `'10'`：贡献 3；
  总共 4。

---

### 示例 2：

```
输入：s = "00111"
输出：0
```

字符串中不存在 `'10'` 模式，无法移动，结果为 0。

---

## 🧠 复杂度分析

* **时间复杂度：** O(n)
  只需一次遍历即可统计所有 `'10'` 的贡献。
* **空间复杂度：** O(1)
  仅用常数变量记录计数。

---

## ✅ 总结

这道题的关键是发现：

* 每个 `'10'` 模式可以让左边所有 `'1'` 向右移动一次；
* 用一个计数器累计 `'1'` 的数量；
* 在遇到 `'10'` 时，将累计的 `'1'` 数量加到结果中。

这是典型的**线性扫描 + 累积贡献**的思路，代码极简但逻辑巧妙，体现了对二进制字符串结构的深入理解。

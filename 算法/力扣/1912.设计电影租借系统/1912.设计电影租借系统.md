# 1912:设计电影租借系统（MovieRentingSystem）

## 题目概述

* 有 `n` 个电影商店，每个商店拥有若干电影拷贝及租赁价格

* 系统需要支持以下操作：

  1. **search(movie)**：查找未借出的指定电影的最便宜 5 个商店（价格升序 → shop 编号升序）
  2. **rent(shop, movie)**：从指定商店借出电影
  3. **drop(shop, movie)**：返还之前借出的电影
  4. **report()**：返回最便宜的 5 部已借出电影（按价格、商店编号、电影编号排序）

* 限制条件：

  * 商店数量 n ≤ 3×10⁵
  * entries 数量 ≤ 10⁵
  * 总操作 ≤ 10⁵

---

## 数据结构设计思路

为了支持高效查询与排序，可以设计如下三个核心数据结构：

### 1️⃣ 电影价格映射

* `unordered_map<pair<int,int>, int>`：

  * key = `(shop, movie)`
  * value = `price`
* 用于快速获取指定商店和电影的价格
* 哈希 key 使用自定义 hash 函数 `pair_hash`

---

### 2️⃣ 未借出的电影集合

* `unordered_map<int, set<pair<int,int>>> m_visited`：

  * key = `movie`
  * value = `set<pair<int,int>>`，存储 `(price, shop)`
  * `set` 自动按 **价格升序 → shop 升序** 排序
* 优点：

  * 查询指定电影未借出的最便宜 5 个商店时，只需遍历 set 的前 5 个元素
  * 插入/删除操作 O(log k)

---

### 3️⃣ 已借出的电影集合

* `set<tuple<int,int,int>> m_unvisited`：

  * tuple = `(price, shop, movie)`
  * 自动按 **价格 → shop → movie** 排序
* 用于 **report()**：

  * 直接取前 5 个元素即可
* 插入和删除 O(log n)

---

## 操作实现思路

### 1️⃣ search(movie)

1. 访问 `m_visited[movie]` → 获取未借出的电影集合
2. 遍历 set 前 5 个元素
3. 返回商店编号列表

**特点**：只需访问少量元素，O(log k + 5) 时间

---

### 2️⃣ rent(shop, movie)

1. 查找价格：`m_price[{shop,movie}]`
2. 从 `m_visited[movie]` 删除 `(price, shop)`
3. 插入到 `m_unvisited`：`(price, shop, movie)`

**特点**：保证 search/报告结果及时更新

---

### 3️⃣ drop(shop, movie)

1. 查找价格：`m_price[{shop,movie}]`
2. 从 `m_unvisited` 删除 `(price, shop, movie)`
3. 插回 `m_visited[movie]` 的 `(price, shop)`

---

### 4️⃣ report()

1. 遍历 `m_unvisited` 前 5 个元素
2. 将 `(shop, movie)` 组合为二维 vector 返回

---

## 核心算法特点

* **时间复杂度**：

  * search：O(log k + 5)
  * rent/drop：O(log k)
  * report：O(5)
* **空间复杂度**：

  * O(n + entries)，存储价格映射和两个集合

---

## 核心总结

1. **价格映射**用于快速查价格
2. **未借出集合**按 `(price, shop)` 排序，快速 search
3. **已借出集合**按 `(price, shop, movie)` 排序，快速 report
4. **借出/归还**通过移动元素在两个集合之间实现
5. 使用 STL 容器 `unordered_map + set + set/tuple`，保证效率和自动排序

> 本质是 **哈希表 + 排序集合** 的组合应用，使查询和报告操作高效且符合题目排序规则。

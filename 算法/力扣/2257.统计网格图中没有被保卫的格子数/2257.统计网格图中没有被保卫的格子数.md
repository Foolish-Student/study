# 2257.统计网格图中没有被保卫的格子数
## 题目
在一个 m × n 的网格中，有若干 警卫（guards） 和 墙（walls）。
每个警卫能向四个方向（上、下、左、右）看到所有格子，
直到遇到另一名警卫或一堵墙为止。
若一个格子被至少一名警卫看到，就认为它被“保卫”；
要求返回所有**空格子**中，没有被任何警卫看到的格子数量。

---

## 🧩 思路分析

1. **网格建模与初始化**

   * 可以用一个二维数组 `grid[m][n]` 表示整个网格。
   * 初始化时：

     * 所有空格子标记为 `0`；
     * 所有警卫和墙标记为 `-1`（表示它们阻挡视线，不可通行）。

2. **模拟警卫视线传播**

   * 对于每个警卫 `(r, c)`，分别向四个方向扩散视线：

     * **向右（东）传播**：从 `c+1` 到 `n-1`；
     * **向左（西）传播**：从 `c-1` 到 `0`；
     * **向下（南）传播**：从 `r+1` 到 `m-1`；
     * **向上（北）传播**：从 `r-1` 到 `0`。
   * 遇到以下情况停止：

     * 碰到墙 (`grid[x][y] == -1`)；
     * 碰到其他警卫 (`grid[x][y] == -1`)。
   * 否则，将格子标记为 `1`（表示被保卫）。

   这样，每个警卫的视线都能覆盖到其四个方向上未被阻挡的区域。

3. **统计未被保卫的格子**

   * 最后遍历整个网格：

     * 如果某个格子仍为 `0`，说明它既不是墙/警卫，也没有被任何警卫的视线覆盖；
     * 这样的格子即为**“未被保卫”**的格子；
     * 统计这些格子的数量。

---

## 🧮 示例分析

### 示例 1

```
m = 4, n = 6
guards = [[0,0],[1,1],[2,3]]
walls = [[0,1],[2,2],[1,4]]
```

* 初始化网格：

  * 3 个警卫和 3 堵墙位置标记为 `-1`；
  * 其他位置初始为 `0`。
* 对每个警卫扩散视线：

  * 警卫 (0,0)：向右遇墙 (0,1) 阻挡；向下能覆盖 (1,0),(2,0),(3,0)；
  * 警卫 (1,1)：向右遇墙 (1,4) 阻挡，能覆盖 (1,2),(1,3)；向上遇墙 (0,1) 阻挡；向下覆盖 (2,1),(3,1)；
  * 警卫 (2,3)：向左遇墙 (2,2) 阻挡；向右覆盖 (2,4),(2,5)；向上覆盖 (1,3)；向下覆盖 (3,3)。
* 最终统计仍为 `0` 的格子个数 = **7**。

✅ 输出：`7`

---

### 示例 2

```
m = 3, n = 3
guards = [[1,1]]
walls = [[0,1],[1,0],[2,1],[1,2]]
```

* 警卫 (1,1) 被墙完全包围；
* 无法扩散任何视线；
* 只有四个角落的格子仍为 `0`。

✅ 输出：`4`

---

## 🧠 复杂度分析

* **时间复杂度：O(m × n)**
  每个格子最多被访问一次（被标记或被阻断）。
* **空间复杂度：O(m × n)**
  使用二维数组存储网格状态。

---

## ✅ 总结

这是一道典型的**二维模拟 + 方向遍历**问题。
主要思路为：

1. 使用网格记录墙与警卫；
2. 从每个警卫出发，沿四个方向扩散视线；
3. 标记被保卫的格子；
4. 最后统计未被标记的格子。

核心要点：

* 墙和警卫同时阻断视线；
* 每个警卫视线独立传播；
* 注意边界和终止条件。

# 2435. 矩阵中和能被 K 整除的路径

## 一、题目大意

给你一个 `m x n` 的网格 `grid`，每个格子里有一个非负整数。你从左上角 `(0,0)` 出发，只能向 **右** 或 **下** 走，最后走到右下角 `(m-1,n-1)`。

我们关心的是：

> 一条路径上所有格子数字的**总和**，是否能被 `k` 整除。

题目要求：

> 返回 **路径和能被 k 整除的路径条数**，结果对 `1e9+7` 取模。

---

## 二、思路分析

### 1️⃣ 朴素想法为什么不行？

最直观的想法是：
枚举从左上角到右下角的每一条路径，算出路径和，看是否能被 `k` 整除。

但是：

* 从左上走到右下，总共要走 `(m-1) + (n-1)` 步
* 每一步有 2 种选择（右/下）
* 路径条数大约是一个组合数 `C(m+n-2, m-1)`，会非常大
  在最坏情况下完全枚举是不现实的。

所以必须用 **动态规划** 来“压缩”状态。

---

### 2️⃣ 关键观察：只关心“和 % k 的结果”

我们不需要知道路径“完整的和是多少”，只需要知道：

> 这条路径的和对 k 取模之后是多少。

也就是说，如果两条路径的和分别是 `sum1` 和 `sum2`，但满足：

> `sum1 % k == sum2 % k`

那么在“接下来继续往下走”这件事情上，它们是**等价的**：
继续加上后面的数字后，最终能否被 k 整除，只跟这个“余数”有关。

因此，我们可以只在 DP 里维护每条路径**到达某个格子时，路径和的余数（0 ~ k-1）**，而不是维护完整的路径和。

---

### 3️⃣ 状态设计：三维 DP 的含义

你的代码中定义了一个三维数组 `dp`：

> `dp[i][j][r]` 表示：
> 从 `(0,0)` 走到 `(i,j)`，且**路径和 mod k == r** 的路径条数。

这里有三层含义：

1. 位置：走到哪一个格子 `(i,j)`
2. 余数：路径和对 k 取模之后等于多少 `r`
3. 值：这一类路径 **有多少条**

注意：

* 第三维 `r` 是 “余数类别”，范围是 `[0, k-1]`
* `dp[i][j][r]` 存的是“路径条数”，不是“和”本身

---

### 4️⃣ 状态转移：当前余数 r 从哪里来？

假设我们现在来到格子 `(i,j)`，格子里的值是 `grid[i][j]`。
我们想知道：

> 有多少条路径可以到 `(i,j)`，并且路径和 % k == r？

一条路径要到 `(i,j)`，只能从两边来：

* 从上方 `(i-1,j)` 往下走一步
* 从左方 `(i,j-1)` 往右走一步

设当前格子值对 k 取余为 `valueMod = grid[i][j] % k`。

假设**上一格**的路径和对 k 的余数是 `prevMod`，那么走到 `(i,j)` 后：

> 新的余数 = `(prevMod + valueMod) % k`

我们希望新的余数是 `r`，于是有：

> `(prevMod + valueMod) % k == r`

反推 `prevMod`：

> `prevMod ≡ r - valueMod (mod k)`
> 在代码里写成：
> `prevMod = (r - valueMod + k) % k`
> （加一遍 k 再取模，保证是非负的 0~k-1）

于是，对每个余数 `r`：

> `dp[i][j][r] = 上面那格的 dp[i-1][j][prevMod]                    + 左边那格的 dp[i][j-1][prevMod]`

也就是说：

* 想要当前余数是 `r`
* 就去“上方/左方”找：**那些“上一格余数 = prevMod” 的路径**，它们加上当前这个格子的值后，就会变成余数 `r`
* 把这两种来源的路径数加起来，就是当前格子余数为 `r` 的路径数

这正是你代码里的逻辑：

* 先算 `valueMod`
* 再枚举当前目标余数 `r`
* 反推出 `prevMod`
* 从上方和左方把对应 `prevMod` 的路径数加过来

---

### 5️⃣ 初始化：起点怎么处理？

起点是 `(0,0)`。
从起点出发，此时路径上只有一个数 `grid[0][0]`，所以：

> 路径和的余数就是 `grid[0][0] % k`

因此：

* 对应这个余数的路径条数是 1
* 其它余数的路径条数是 0

在你的写法中，就是在循环遇到 `(0,0)` 时：

* 只给 `dp[0][0][grid[0][0] % k] = 1`
* 然后 `continue` 掉，后面不需要再算。

这样后面的 DP 转移就有了“起点”的基础。

---

### 6️⃣ 边界处理：第一行和第一列

由于代码是从 `(0,0)` 一路循环到 `(m-1,n-1)`，并且访问前面的 `dp[i-1][j]` 和 `dp[i][j-1]` 时都会先判断：

* 若 `i > 0` 才能取上面一格
* 若 `j > 0` 才能取左边一格

所以：

* 第一行只能从左边来（因为没有上面）
* 第一列只能从上边来（因为没有左边）

这些边界情况都被条件判断自然地处理掉了。

---

### 7️⃣ 为什么要对 MOD = 1e9+7 取模？

随着 `i, j` 逐渐增大，到达每个格子的路径条数会迅速增长，对 `int` / `long long` 都有可能溢出。

题目明确要求：

> “由于答案可能很大，返回答案对 10^9 + 7 取余的结果。”

因此，当我们在做转移时：

> `dp[i][j][r] = (topMod + leftMod) % MOD;`

这里取模的是：

* **路径条数之和**，以防数值过大，同时满足题目要求。

这一点和“对 k 取模”是完全不同的概念：

* `% k` 用来处理“路径和的余数”
* `% MOD` 用来处理“路径条数本身的大小”

---

### 8️⃣ 最终答案怎么取？

终点是 `(m-1, n-1)`，我们只关心：

> 路径和能被 k 整除，也就是：
> `路径和 % k == 0` 的路径条数。

根据 DP 定义：

* `dp[m-1][n-1][0]`
  恰好就代表：
  “从起点走到终点，路径和 % k == 0 的路径数量”。

因此，返回这个值即可。

---

## 三、复杂度分析

我们有三维 DP：

* 位置维度：`m` 行、`n` 列
* 余数维度：`k` 种余数（0 ~ k-1）

每个状态 `dp[i][j][r]` 的转移是 O(1) 的（只从上方和左方取一次），因此：

* 时间复杂度：
  `O(m * n * k)`
  考虑题目给的约束 `m * n <= 5 * 10^4`、`k <= 50`，最大大约是 `2.5 * 10^6` 级别，可以接受。
* 空间复杂度：
  `O(m * n * k)`，即三维数组的大小。

---

## 四、小结

整道题的核心可以概括为几句话：

1. 我们不直接存“路径和”，而是存“路径和对 k 的余数 r”。
2. 用 `dp[i][j][r]` 表示：到 `(i,j)` 且余数为 `r` 的路径条数。
3. 转移时根据 `(prevMod + 当前格子值) % k == r`，反推 `prevMod`，从上/左两格把对应路径条数加过来。
4. 起点只初始化其对应余数那一格为 1。
5. 最终答案就是终点位置余数为 0 的路径条数：`dp[m-1][n-1][0]`。


# 1625.执行操作后字典序最小的字符串

## 一、题意速读

给定偶数长度数字串 `s`（仅含 0–9）与整数 `a、b`，可无限次执行两种操作：

1. **累加**：把当前串中**奇数下标**位都加上 `a`（对 10 取模）。
2. **右轮转**：把整串**向右轮转** `b` 位。
   目标：得到**字典序最小**的字符串。

## 二、关键观察（本题的“开锁钥匙”）

1. **加法成环**
   对任一数位，重复做“+a（mod 10）”最多 10 次必回到原值。因此：

* 对“能被加到”的那一类位置（奇/偶），把**加 0..9 次**都枚举，已覆盖所有可能。

2. **轮转成环**
   右移 `b` 位在模 `n`（`n=|s|`）的环上形成长度 `n/g=gcd(n,b)` 的**循环轨道**：
   可达起点集合是 `{0, b, 2b, ..., (L-1)b} (mod n)`，其中 `L = n/g`。
   顺着序列 `i = (i + b) % n`，直到遇见访问过的位置，即**恰好走完整个轨道**。

3. **奇偶性的决定性作用**

* 若 **`b` 为偶数**：无论轮转多少次，原“奇位/偶位”的集合 **不会互换**；因此**只能给奇数下标位加法**，偶数位**永远加不到**（枚举偶数位加法次数 `k=0` 即可）。
* 若 **`b` 为奇数**：轮转会使两类位置交替落到当前串的奇数下标，意味着**奇/偶两类位都能被加**；因此**奇位加 `j=0..9`，偶位加 `k=0..9`** 都要枚举。

> 以上三点意味着：**轮转次数**与**加法次数**可以“分开枚举”。
> 对每个可达的轮转结果，再穷举加法次数（按奇偶性规则），就能覆盖**全部可达字符串**。

## 三、算法步骤

1. 令 `n = s.length()`，把 `s` 拼成 `s + s`，方便从任意起点 `i` 直接 `substr(i, n)` 取出右移后的字符串。
2. 用 `vis[n]` 记录已经访问过的起点。按 `i = (i + b) % n` 遍历全部可达起点（遇重复即停）。
3. 对每个右移结果 `t = (s+s).substr(i, n)`：

   * 穷举 **奇位加法次数** `j = 0..9`；
   * 若 `b` 偶数，则 **偶位加法次数** `k=0`；若 `b` 奇数，则 `k = 0..9`；
   * 按 `(digit + j*a) % 10` 更新奇下标位，按 `(digit + k*a) % 10` 更新偶下标位；
   * 维护字典序最小的答案。

## 四、正确性要点（简要证明）

* 轮转：我们按步长 `b` 在模 `n` 的环上前进，长度为 `n/gcd(n,b)` 的循环轨道被完整遍历；因此**所有不同的轮转结果**都考虑到了。
* 加法：每个可加的**位类**（奇/偶）都枚举了 `0..9` 次数，覆盖该类位的所有模 10 状态；`b` 偶数时偶位不可达，故 `k=0` 合理。
* 组合：对每个轮转结果独立枚举加法次数，**积木式**覆盖所有可达字符串。因此一定能得到全局最小。

## 五、复杂度

* 起点数 ≤ `n`
* `j` 有 10 种；`k` 为 1 种（`b` 偶）或 10 种（`b` 奇）
* 每次改串 O(n)
  总复杂度：**O(n × 10 × (b%2?10:1) × n) ≈ O(100·n²)**，`n ≤ 100` 完全可接受。
  空间：O(n)。


## 六、举个小例子（帮助直觉）

`s="74", a=5, b=1（奇）`
可达起点：`i=0,1` → `t∈{"74","47"}`

* 对 `t="74"`：奇位(1)枚举 `j=0..9`，偶位(0)枚举 `k=0..9`
  例如 `j=0,k=1` → 偶位 7→2，奇位 4 保持 → `"24"`
* 对 `t="47"`：同理枚举
  最终最小 `"24"`。

## 七、其他做法简评

* **BFS**（状态=字符串，边=两种操作）也能求最小，但状态多、常数大，不如本法高效稳妥。
* **数学化降维**是关键：把“可达轮转 + mod 10 的加法”拆开穷举，避免爆炸的状态图。


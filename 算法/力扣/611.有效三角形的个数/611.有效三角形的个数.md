# 611.有效三角形的个数

## 题目概述

* 给定一个非负整数数组 `nums`
* 求数组中可以组成三角形的三元组 `(a, b, c)` 的个数
* 三角形成立条件：任意两边之和大于第三边

  * 对于排序后的三边 `a ≤ b ≤ c` → 只需判断 `a + b > c`

### 示例

1. `nums = [2,2,3,4]` → 有效三元组：

   * 2,2,3
   * 2,3,4（使用第一个 2）
   * 2,3,4（使用第二个 2）
   * 总数 = 3

2. `nums = [4,2,3,4]` → 总数 = 4

---

## 解题思路

### 1️⃣ 排序数组

* 将数组从小到大排序
* 排序后的三角形条件更容易判断：

  * 对于三元组 `(nums[i], nums[j], nums[k])` 且 `i < j < k`
  * 只需判断 `nums[i] + nums[j] > nums[k]`

---

### 2️⃣ 双指针 + 二分查找

* 固定前两条边 `nums[s]` 和 `nums[e]`
* 对第三条边 `nums[k]` 使用 **二分查找**：

  * 查找第一个 **不满足 `nums[s] + nums[e] > nums[k]`** 的位置
  * 该位置左边的元素都是有效的第三条边
* 统计满足条件的 `k` 数量，累加到结果

---

### 3️⃣ 遍历组合

* 外层循环固定第一条边 `s`
* 内层循环固定第二条边 `e = s + 1`
* 每次计算 `nums[s] + nums[e]`，用二分查找 `k`
* 更新统计结果后，移动 `e`
* 当 `e` 到达数组末尾，移动 `s`，重置 `e = s + 1`
* 直到遍历所有可能的前两条边

---

### 4️⃣ 核心技巧

1. **排序** → 保证 `nums[i] ≤ nums[j] ≤ nums[k]`
2. **二分查找** → 快速找到第三条边的上限
3. **双指针遍历前两条边** → 遍历所有组合，不重复统计
4. **复杂度**：

   * 排序：O(n log n)
   * 双指针 + 二分查找：O(n² log n)

---

## 核心思想

* 将三角形条件 `a + b > c` 转化为排序数组中的索引判断
* 利用 **排序 + 二分** 提高效率
* 双指针遍历前两条边，结合二分确定有效第三条边数量

> 本质是 **枚举前两条边 + 二分搜索第三条边** 的组合问题，通过排序优化搜索范围，提高时间效率。

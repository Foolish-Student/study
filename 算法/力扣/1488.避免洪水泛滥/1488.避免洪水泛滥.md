# 1488. 避免洪水泛滥
## 一、题目描述
你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨前是空的，那么它就会装满水。如果第 n 个湖泊下雨前是满的，这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。

给你一个整数数组 `rains`，其中：
- `rains[i] > 0` 表示第 i 天时，第 `rains[i]` 个湖泊会下雨。
- `rains[i] == 0` 表示第 i 天没有湖泊会下雨，你可以选择一个湖泊并抽干这个湖泊的水。

请返回一个数组 `ans`，满足：
1. `ans.length == rains.length`
2. 如果 `rains[i] > 0`，那么 `ans[i] == -1`。
3. 如果 `rains[i] == 0`，`ans[i]` 是你第 i 天选择抽干的湖泊。

如果有多种可行解，请返回它们中的任意一个。如果没办法阻止洪水，请返回一个空的数组。

**注意**：如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。


### 示例
- **示例 1**：
  输入：`rains = [1,2,3,4]`
  输出：`[-1,-1,-1,-1]`
  解释：每天都下雨且湖泊均为首次下雨，无洪水风险，无需抽干操作。

- **示例 2**：
  输入：`rains = [1,2,0,0,2,1]`
  输出：`[-1,-1,2,1,-1,-1]`
  解释：第二天后湖泊 1、2 装满；第三天抽干湖泊 2，第四天抽干湖泊 1；后续下雨时湖泊均为空，无洪水。

- **示例 3**：
  输入：`rains = [1,2,0,1,2]`
  输出：`[]`
  解释：第三天仅能抽干一个湖泊，后续第五天两个湖泊均会再次下雨，必然有一个湖泊洪水。


## 二、解题思路
### 核心问题分析
洪水的本质是「同一湖泊在未被抽干的情况下再次下雨」，因此解题的关键是：**当某个湖泊再次下雨时，必须找到上一次下雨之后、本次下雨之前的一个晴天，将该湖泊抽干**。若找不到这样的晴天，则无法避免洪水。


### 具体思路拆解
#### 1. 数据结构选择
为实现上述目标，我们需要两个核心数据结构来存储关键信息：
- **`unordered_map<int, int> lakeMap`**：记录每个湖泊上一次下雨的日期。键为湖泊编号，值为该湖泊最近一次下雨的索引（第几天），用于快速判断湖泊是否已装满水，以及获取上一次下雨的时间。
- **`set<int> lakeSet`**：记录所有晴天的日期索引。`set` 内部元素有序的特性，能帮助我们快速找到「上一次下雨之后的第一个晴天」（利用二分查找思想），同时支持高效删除已使用的晴天（避免重复利用）。
- **`vector<int> res`**：存储最终结果，初始值设为 1（若晴天未被分配抽干任务，默认抽干任意空湖泊即可，1 是合法选择）。


#### 2. 遍历处理每一天
我们按时间顺序（索引从 0 到 n-1）遍历 `rains` 数组，分两种情况处理每一天：

##### 情况 1：当天是晴天（`rains[i] == 0`）
此时无需立即决定抽干哪个湖泊（避免过早选择导致后续无合适晴天可用），只需将当前晴天的索引存入 `lakeSet` 中，留待后续下雨时按需分配。同时，`res[i]` 暂时保持初始值 1，后续若被分配任务再更新。


##### 情况 2：当天是雨天（`rains[i] > 0`）
设当前下雨的湖泊为 `lake`，当前日期索引为 `i`，处理步骤如下：
1. **标记雨天结果**：根据题目要求，雨天的结果固定为 -1，因此直接将 `res[i]` 设为 -1。
2. **检查湖泊是否已装满水**：通过 `lakeMap` 查找 `lake` 是否存在（即是否上一次下雨后未被抽干）。
   - **若湖泊未装满水（`lakeMap` 中无该湖泊）**：直接将 `lake` 和当前索引 `i` 存入 `lakeMap`，记录该湖泊首次下雨的时间，无需其他操作。
   - **若湖泊已装满水（`lakeMap` 中有该湖泊）**：需要找到上一次下雨之后的第一个晴天来抽干湖泊，避免洪水：
     - 从 `lakeMap` 中获取该湖泊上一次下雨的索引 `lastRainDay`。
     - 在 `lakeSet` 中查找 **大于 `lastRainDay` 的最小晴天索引**（利用 `set` 的 `lower_bound` 方法，该方法本质是二分查找，时间复杂度 O(log m)，m 为晴天数量）。
     - **若找不到这样的晴天**（`lower_bound` 返回 `lakeSet` 末尾迭代器）：说明无法避免洪水，直接返回空数组。
     - **若找到这样的晴天**：将该晴天索引对应的 `res` 值更新为 `lake`（表示当天抽干该湖泊），同时从 `lakeSet` 中删除该晴天索引（避免后续重复使用）。
3. **更新湖泊最近下雨时间**：无论该湖泊是否已装满水，都需将 `lakeMap[lake]` 更新为当前索引 `i`，记录最新的下雨时间，为后续可能的再次下雨做准备。


#### 3. 返回结果
遍历结束后，若未触发洪水返回空数组的情况，则 `res` 中已记录了合法的每日操作，直接返回 `res` 即可。


## 三、思路优势
1. **高效性**：利用 `set` 的有序性和二分查找特性（`lower_bound`），确保每次查找晴天的时间复杂度为 O(log m)；`unordered_map` 的查找和更新操作时间复杂度为 O(1)，整体遍历时间复杂度为 O(n log m)（n 为总天数），能满足题目中 `n <= 1e5` 的数据规模要求。
2. **合理性**：晴天不提前分配任务，而是留待后续下雨时按需选择，避免了「过早选择晴天导致后续无可用晴天」的问题，最大化利用了每一个晴天的价值。
3. **简洁性**：数据结构职责清晰，逻辑流程顺时间展开，符合直觉，易于理解和实现。
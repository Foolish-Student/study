# 2300.咒语和药水的成功对数

## 一、题目概述（一句话）

给定 `spells` 和 `potions` 两个正整数数组以及阈值 `success`，对于每个咒语 `spell`，统计有多少瓶药水 `potion` 满足 `spell * potion >= success`。

---

## 二、核心思想（数学推导 + 二分）

* 对于固定的 `spell`，不需要逐个试乘。把不等式变形：
  [
  spell \times potion \ge success \quad\Longrightarrow\quad potion \ge \frac{success}{spell}.
  ]
* 因为 `potion` 是整数，我们需要 **向上取整**：`required = ceil(success / spell)`。凡是 `potion >= required` 的药水都能与该 `spell` 配对成功。
* 因此只要把 `potions` 排序，对每个 `spell` 用 `lower_bound`（找第一个 `>= required`）就能知道满足条件的药水数量：`count = potions.size() - pos`。

---

## 三、实现要点与注意事项

1. **排序**：先对 `potions` 升序排序（只需排序一次）。
2. **向上取整的安全计算**：

   * `required = ceil(success / spell)` 可以写成整数运算 `required = (success + spell - 1) / spell`。
   * 但 `success` 的上限可能较大（题目中可到 (10^{10})），所以必须使用 `long long`（或等价 64 位整数）来保存 `success` 与中间计算，避免溢出。
3. **使用二分查找**：

   * `lower_bound` 找到第一个 `>= required` 的位置 `it`。
   * 若 `it == potions.end()`，说明此 `spell` 没有任何能配对的药水（结果为 0）。
   * 否则数量为 `potions.end() - it`。
4. **变量类型统一**：`spell`、`potions` 元素在乘法比较中要注意类型转换（用 `long long`），但用上述变形后只需对 `required` 做长整型计算即可（避免直接乘法导致溢出）。

---

## 四、复杂度分析

* 排序 `potions`：(O(m \log m))（(m=) potions 长度）。
* 对每个 `spell` 做一次二分查找：(n \times O(\log m))。
* 总时间复杂度：(O(m \log m + n \log m))。
* 空间复杂度：排序就地进行，额外 (O(1)) 或 (O(\log m)) 取决于排序实现（忽略输出数组），总体很小。

在题目给定的限制（(n,m \le 10^5)）下，这个解法是高效且可行的。

---

## 五、示例演示（用样例 1）

* `spells = [5,1,3]`, `potions = [1,2,3,4,5]`, `success = 7`
* 先 sort `potions`（已经有序）。
* 对 `spell=5`：`required = ceil(7/5) = 2` → lower_bound 找到第一个 >=2 的位置（指向 2），满足数 = 5-1 = 4。
* 对 `spell=1`：`required = ceil(7/1) = 7` → lower_bound 超出末尾，满足数 = 0。
* 对 `spell=3`：`required = ceil(7/3) = 3` → lower_bound 指向 3，满足数 = 5-2 = 3。
* 返回 `[4,0,3]`。

---

## 六、可选的变体与优化

* **两指针 + 排序咒语带索引**：可以把 `spells` 连同原始下标一起按升序或降序排序，然后与排序好的 `potions` 用双指针线性扫（从大到小或小到大），把每个 `spell` 对应的计数推导出来，能把二分换成线性扫描，加速常数。但实现复杂度和逻辑上没有二分简单清晰。
* **注意边界情况**：

  * `spell` 或 `potion` 为 0 的情况题目中不会出现（题目保证元素 >= 1）。
  * `success` 非正的情况（题目中 success >= 1），若 `success==0` 则所有对都成功（无需计算），但不是本题场景。

---

## 七、总结

* 把乘积条件转换为“药水下界” `potion >= ceil(success / spell)`，这是关键的数学变形。
* 预排序 `potions`，对每个 `spell` 用 `lower_bound` 查第一个满足的索引，结果由 `end - it` 得到。
* 注意用 `long long` 做中间计算以避免溢出；时间复杂度 (O(m \log m + n \log m))，在题目规模内非常合适。

# 3542.将所有元素变为 0 的最少操作次数

## 题目
给定一个由非负整数构成的数组 `nums`，你可以进行若干次操作。
每次操作可以选择一个连续子数组 `[i, j]`，并将其中所有 **最小的非零整数** 设为 0。
目标是使整个数组所有元素都变为 0，并返回所需的最少操作次数。

---

## 🧩 思路分析

这道题的关键是：
一次操作只能“消除”一个子数组中的**最小值**，因此每个位置的变化只与它**前面比它大的数**相关。
为了最小化操作次数，我们需要找出每个数在整体“递减趋势”中的断点。

---

### 1️⃣ 核心直觉：

* 每次操作相当于“清除”一段连续的递增或相等的区间；
* 当出现一个比前面数字更小的值时，之前的递增部分被“打断”，意味着必须进行一次新的操作；
* 因此，每次从“高处下降”都对应一次独立的操作。

---

### 2️⃣ 采用单调栈模拟“层层清零”的过程

使用一个单调递增栈 `s`，用来维护当前“递增序列”中尚未被清除的数：

* **遍历数组每个元素 `num`**：

  * 若 `num` **小于栈顶元素**，说明递增序列被打断；

    * 栈中比 `num` 大的部分要清除，意味着产生一次操作；
    * 逐个弹出栈中比 `num` 大的元素，同时操作数 `res++`；
  * 若 `num` 大于栈顶（或者栈为空），将 `num` 入栈；
  * 若 `num == 0`，不需要处理，因为 0 已经“被清除”。
* 遍历结束后，栈中剩余的数表示还需独立清除的“递增层”，它们也各需要一次操作。

---

### 3️⃣ 操作次数统计公式

最终结果为：

```
操作次数 = 弹栈次数 + 栈中剩余元素个数
```

也就是：

* 每次下降触发一次清除；
* 最后未被打断的递增层也需要逐层清理。

---

## 🧮 示例分析

### 示例 1：

```
nums = [0,2]
```

* 0 不需操作；
* 2 入栈；
* 最终栈内：[2]；
  ✅ 总操作 = 1。

---

### 示例 2：

```
nums = [3,1,2,1]
```

| 步骤 | 当前数 | 栈变化      | 新操作数 |
| -- | --- | -------- | ---- |
| 3  | [3] | 入栈       | 0    |
| 1  | [ ] | 弹出 3（下降） | +1   |
| 2  | [2] | 入栈       | 0    |
| 1  | [ ] | 弹出 2（下降） | +1   |

最后栈为空，再加上最后一层 `[1]` 的清除。
✅ 总操作 = 2 + 1 = 3。

---

### 示例 3：

```
nums = [1,2,1,2,1,2]
```

* [1] → [1,2]（递增）
* 下一位 1 → 下降，清除一次
* 再次形成 [1,2] → 下一位 1 再下降，继续清除
  最终共有 3 次下降 + 最后一层清除。
  ✅ 总操作 = 4。

---

## 🧠 复杂度分析

* **时间复杂度：** O(n)
  每个元素最多入栈、出栈一次。
* **空间复杂度：** O(n)
  使用一个辅助栈。

---

## ✅ 总结

这道题的本质是用**单调栈**追踪“高度层次变化”的过程：

* 每次下降意味着需要额外的操作；
* 每个递增层对应一次独立的清除过程。

这种思路避免了重复扫描或模拟每一步操作，用栈结构高效地完成了整个“清零过程”的统计。

# 717.1比特与2比特字符
## 题目
给定一个二进制数组 `bits`，数组仅由 `0` 和 `1` 组成。
其中：

* “一比特字符”用单独的 `0` 表示；
* “两比特字符”用 `10` 或 `11` 表示。

数组保证以 `0` 结尾。
要求判断：**最后一个字符是否必然是“一比特字符”。**

---

## 🧩 思路分析

题目的本质是 **按照给定的编码规则，从左到右解析整个比特流**，看最后的 `0` 是否独立存在。

规则：

* 若当前位置为 `0`，说明是一个 **1 比特字符**，只占一个位置；
* 若当前位置为 `1`，说明是一个 **2 比特字符**，占用当前位置和下一个位置。

---

### 1️⃣ 遍历策略

我们可以从头开始扫描数组：

* 若遇到 `0`，只跳过一个比特；
* 若遇到 `1`，说明接下来两个比特构成一个字符，因此跳过两个比特。

这样每次跳过的步长由当前比特决定。

---

### 2️⃣ 关键判断

我们只需关注 **是否停在了最后一位（n - 1）上**：

* 如果最终停在最后一个位置（即 `i == n - 1`），
  说明最后一个 `0` 没被两比特字符“占用”，它是独立的 → 返回 `true`。
* 若在扫描过程中越过了末尾（`i == n`），
  说明最后一个 `0` 是两比特字符的一部分 → 返回 `false`。

---

### 3️⃣ 示例分析

#### 示例 1

```
bits = [1,0,0]
```

解析过程：

* `i = 0`：`bits[0] = 1` → 两比特字符（10），跳过 2 位 → `i = 2`
* `i = 2`：停在最后一位（`bits[2] = 0`）

✅ 最后一个是独立的 `0` → 输出 `true`

---

#### 示例 2

```
bits = [1,1,1,0]
```

解析过程：

* `i = 0`：`bits[0] = 1` → 跳过 2 位 → `i = 2`
* `i = 2`：`bits[2] = 1` → 跳过 2 位 → `i = 4`（越界）

❌ 最后一个 `0` 被当作两比特字符的一部分 → 输出 `false`

---

## 🧠 复杂度分析

* **时间复杂度：** O(n)
  只需线性遍历数组一次；
* **空间复杂度：** O(1)
  仅使用常数变量。

---

## ✅ 总结

这道题的关键在于 **模拟解码过程**，
而不是直接数 `1` 或判断结尾模式。
通过不断跳过 1 或 2 个比特，最后看指针是否停在末尾即可判断。

这种方法简洁高效，体现了对题目编码规则的直观理解与模拟实现。

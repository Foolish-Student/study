# 1039.多边形三角剖分的最低得分

## 一、问题概述

给定一个凸多边形，每个顶点都有一个整数值。

* 输入：数组 `values`，表示顶点值，顺时针排列
* 操作：将多边形剖分为 `n-2` 个三角形
* 三角形得分 = 三个顶点值的乘积
* 目标：**最小化所有三角形得分之和**

示例：

```
values = [3,7,4,5] 
最小得分三角剖分 = 144
```

---

## 二、DFS（记忆化递归）思路

### 1. 基本思路

* 将问题拆解为 **区间 `[i,j]` 内顶点形成的子多边形**
* 对于区间 `[i,j]`，选择分割点 `k`（`i < k < j`）：

  * 三角形 `(i,k,j)` 得分 = `values[i]*values[k]*values[j]`
  * 子区间 `[i,k]` 和 `[k,j]` 递归求最小得分
* 区间内所有分割点的结果取最小值

### 2. 优化

* 使用二维数组 `visit[i][j]` 记录已计算的子区间最小得分
* 避免重复计算 → **记忆化递归**
* 最终答案 = `dfs(0, n-1)`

### 3. 特点

* 直观、符合递归思路
* 缺点：每次递归会创建多个函数调用，栈深度较大
* 对 `n` 较大时性能略低

---

## 三、区间 DP 思路（推荐）

### 1. 状态定义

* `dp[i][j]` = 顶点 `i` 到 `j` 的子多边形的最小三角剖分得分

### 2. 状态转移

* 对于区间 `[i,j]`，枚举分割点 `k`：

```
dp[i][j] = min(dp[i][k] + dp[k][j] + values[i]*values[k]*values[j])  for k = i+1..j-1
```

* 子区间 `[i,k]` 和 `[k,j]` 已预先计算
* 跨越顶点 `i,k,j` 的三角形得分加上子区间得分 → 当前区间得分
* 取最小值更新 `dp[i][j]`

### 3. 填表顺序

* 区间长度从短到长依次填：

  * 长度 2 → 唯一三角形，直接计算得分
  * 长度 3 以上 → 依赖已计算的短区间
* 最终答案：`dp[0][n-1]`

### 4. 复杂度分析

* **时间复杂度**：O(n³)
* **空间复杂度**：O(n²)

---

## 四、总结

* **DFS + 记忆化**：

  * 优点：实现直观
  * 缺点：递归调用多，稍慢

* **区间 DP**：

  * 优点：状态明晰，填表顺序固定，便于优化
  * 核心思想：**“区间最优子结构 + 分割点枚举”**
  * 适合凸多边形最优剖分、序列切分等问题

* 两种方法本质一致：都是 **考虑区间 `[i,j]` 的最优划分**，只是实现方式不同。

> 认知锚点：区间 DP 是解决凸多边形最小/最大三角剖分问题的经典方法，也是**区间最优子结构问题**的代表案例。

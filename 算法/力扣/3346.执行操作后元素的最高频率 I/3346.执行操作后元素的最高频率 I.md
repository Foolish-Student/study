# 3346.执行操作后元素的最高频率 I

## 🧩 题目描述

给定一个整数数组 `nums`，以及两个整数 `k` 和 `numOperations`。
你需要执行 `numOperations` 次操作，每次可以选择一个**未被选择过的下标 i**，并将 `nums[i]` 加上或减去一个范围在 `[-k, k]` 内的整数。

操作完成后，返回数组中某个元素可能达到的**最高出现频率**。
也就是说——经过最多 `numOperations` 次调整后，数组中某个数最多能出现多少次。

---

## 💡 思路解析

题目的核心是一个“**频率最大化 + 区间可调整**”问题。
每个元素都可以在区间 `[num - k, num + k]` 范围内任意变动一次，我们要找出**在所有可能变换中**，能让某个数出现次数最多的情况。

---

### 🔹 Step 1：排序与频率统计

首先对 `nums` 排序，这样相邻的元素在数轴上更接近。
排序后我们能更方便地判断“哪些数经过调整后可能重合”。

然后，我们统计每个数当前的出现频率，用哈希表 `numMap` 保存：

* `numMap[x] = 出现次数`
* 同时记录目前数组中出现频率的最大值 `res`

这样，我们在后续尝试“合并可调整范围”时，有一个初始频率上界。

---

### 🔹 Step 2：枚举目标值（假设调整后想让它成为众数）

对于排序后的数组，我们枚举可能的“目标数值” `i`，即可能成为最高频率的数。
`i` 取值范围是 `[nums.front(), nums.back()]`。

对于每一个 `i`，我们考虑哪些原始元素能被调整到 `i`：

* 若某元素 `x` 满足 `i ∈ [x - k, x + k]`，那么它可以通过一次操作变成 `i`。

换句话说，我们要找出所有在区间 `[i - k, i + k]` 内的元素。

---

### 🔹 Step 3：区间查找（利用二分法加速）

因为数组是有序的，我们可以用 STL 的二分查找函数：

```cpp
auto l = lower_bound(nums.begin(), nums.end(), i - k);
auto r = upper_bound(nums.begin(), nums.end(), i + k);
```

* `l` 指向第一个 ≥ (i - k) 的位置；
* `r` 指向第一个 > (i + k) 的位置；
* 区间 `[l, r)` 中的元素都是能“变成 i”的候选。

因此：

```cpp
int w = r - l;   // 能调整为 i 的元素个数
```

---

### 🔹 Step 4：计算可能的最大频率

对于当前 `i`：

* 其中已有 `numMap[i]` 个数等于 `i`；
* 其余元素中，最多还能有 `numOperations` 个被修改成 `i`；
* 但我们最多只能使用 `w` 个可调整候选。

所以当前 `i` 能达到的最大频率为：

[
\text{maxFreq}(i) = \min(w, \text{numMap}[i] + \text{numOperations})
]

不断更新：

```cpp
res = max(res, maxFreq(i));
```

---

### 🔹 Step 5：返回结果

遍历所有可能的目标值 `i` 后，`res` 即为最终结果。

---

## 🧠 思维总结

| 步骤          | 核心操作                    | 目的      |
| ----------- | ----------------------- | ------- |
| ① 排序 + 哈希统计 | 获得基础频率信息                | 方便区间判断  |
| ② 枚举目标值     | 假设所有数变为同一个目标            | 探索可能性   |
| ③ 二分查找      | 高效定位可调整区间               | 减少时间复杂度 |
| ④ 贪心计算频率    | 用 `min(w, 当前频率 + 操作次数)` | 确保合法且最优 |
| ⑤ 更新答案      | 保留最大值                   | 输出结果    |

---

### ⏱️ 复杂度分析

| 项目    | 复杂度                                                      |
| ----- | -------------------------------------------------------- |
| 时间复杂度 | O(n log n + R log n)，其中 R 为 `nums.back() - nums.front()` |
| 空间复杂度 | O(n)，用于存储哈希表与辅助数组                                        |

---

### ✨ 思路总结一句话

> 通过排序 + 二分查找确定每个目标值的可调整范围，再结合贪心策略计算可达到的最高频率，从而得到最终结果。

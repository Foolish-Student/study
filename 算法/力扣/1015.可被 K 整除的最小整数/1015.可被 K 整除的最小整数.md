# 1015. 可被 K 整除的最小整数

题目要求：
找到一个 **仅由数字 1 组成** 的正整数（如 1、11、111…），判断它们中**最短的一个**能否被 k 整除，并返回它的长度。

这种数叫 **R(k)**：

```
R(1) = 1
R(2) = 11
R(3) = 111
...
```

但这些数可能非常大，不能直接构造，需要用数学方法。

---

# 📌 核心思路：构造“111…”时只维护 mod k

对于长度为 n 的数：

```
111…1 = 前一个数 * 10 + 1
```

为了判断是否能被 k 整除，我们只需要维护它的余数：

令

```
res = 当前构造的数 mod k
```

每增加一个“1”：

```
res = (res * 10 + 1) % k
```

当 res == 0 时：

👉 表示这个由 n 个 1 构成的数能被 k 整除
👉 答案就是 n

---

# ❗ 为什么要使用集合（或数组）记录出现过的余数？

因为一旦余数开始重复，就说明我们进入了循环：

* 后面会无限重复相同的余数
* 因此永远不会得到余数 0

这一点类似 **检测循环节** 的思路。

举例：

如果某次 res = x，并且之后又出现 res = x
说明从这之后的所有计算都会重复
因此不可能整除 → 返回 -1

---

# 🚫 为什么 k 能被 2 或 5 整除时一定没有答案？

因为只由 1 组成的数必定是：

* **奇数**
* **末尾数字为 1**

这样的数绝不可能被 2 或 5 整除
因此直接返回 -1。

你的代码通过循环检测可以推导得出这一点。

---

# ✔ 示例

### 示例 1

```
k = 1
1 % 1 = 0 → 长度为 1
```

### 示例 2

```
k = 2
无论多少个 1 结尾都为 1 → 不可能被 2 整除 → -1
```

### 示例 3

```
k = 3
111 % 3 = 0 → 长度为 3
```

---

# ⏱ 复杂度分析

* **时间复杂度：O(k)**
  最多只会出现 k 种不同的余数，一旦重复就结束。

* **空间复杂度：O(k)**
  用集合记录出现过的余数。

---

# 🎯 总结

本题核心点：

* 使用余数滚动计算 `(res * 10 + 1) % k`
* 利用集合检测余数循环
* 计算出最短的由 1 构成且能被 k 整除的整数长度
* 若无答案则返回 -1

这是一个经典的“重复余数 + 构造大数 mod”的问题，思想非常常用。

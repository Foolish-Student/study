# 3349.检测相邻递增子数组 I

---

## 一、题目理解

给定一个整数数组 `nums` 和一个整数 `k`，我们需要判断是否存在两个 **相邻**、长度均为 `k` 的 **严格递增子数组**。

具体来说，若存在起点下标 `a` 和 `b` 满足：

* `nums[a..a+k-1]` 和 `nums[b..b+k-1]` 都是严格递增序列；
* 且 `b = a + k`（即这两个子数组紧挨着）；

那么返回 `true`，否则返回 `false`。

---

## 二、思路分析

### ✅ 1. 拆分问题

要检查“是否存在两个相邻的递增子数组”，可转化为：

* **枚举第一个子数组的起点** `a`；
* 检查 `nums[a..a+k-1]` 和 `nums[a+k..a+2k-1]` 是否**都递增**。

只要有一组满足条件，就能立刻返回 `true`。

---

### ✅ 2. 严格递增的判断

对于一个区间 `[start, end)`，如果要判断是否严格递增，只需要逐项比较：

```
nums[i] < nums[i + 1]
```

若在区间中发现任意一对不满足这个关系，即说明该区间不是严格递增的。

例如：

* `[2,3,4]` ✅ 递增；
* `[2,2,3]` ❌ 因为存在相等。

---

### ✅ 3. 遍历方式

由于题目要求相邻的两个长度为 `k` 的子数组，因此第一个子数组的起点 `a` 只需枚举到：

```
a <= n - 2k
```

因为若 `a > n - 2k`，后面已经不够两个完整的长度为 `k` 的子数组。

---

## 三、算法流程

1. 遍历所有可能的起点 `a`，范围是 `[0, n - 2k]`。
2. 对每个 `a`：

   * 检查 `[a, a + k)` 是否严格递增；
   * 检查 `[a + k, a + 2k)` 是否严格递增；
3. 若两者都满足，则返回 `true`。
4. 如果所有 `a` 都检查完未满足，则返回 `false`。

---

## 四、示例推导

### 示例 1

```
nums = [2,5,7,8,9,2,3,4,3,1], k = 3
```

遍历：

* 起点 0: [2,5,7] ✅ 递增，但下一个 [8,9,2] ❌；
* 起点 1: [5,7,8] ✅，但下一个 [9,2,3] ❌；
* 起点 2: [7,8,9] ✅，下一个 [2,3,4] ✅；

→ 两个相邻递增子数组出现，返回 **true**。

---

### 示例 2

```
nums = [1,2,3,4,4,4,4,5,6,7], k = 5
```

任意两个相邻长度为5的子数组都包含相等的“4”，无法满足严格递增条件，返回 **false**。

---

## 五、复杂度分析

| 项目    | 复杂度                      |
| ----- | ------------------------ |
| 时间复杂度 | O(n × k)，每个起点最多检查 2k 个元素 |
| 空间复杂度 | O(1)，只使用常量空间             |

---

## 六、思路总结

本题是一道**暴力枚举 + 子数组验证**类型的题，思路清晰、实现简单。
关键在于理解题意中的“相邻”和“严格递增”：

* “相邻”意味着第二个子数组的起点紧跟第一个的终点；
* “严格递增”意味着连续比较 `<`，不能出现相等。

> 💡 总结一句话：
> **滑动窗口判断相邻两段长度为 k 的递增区间，一旦同时递增即可返回 true。**

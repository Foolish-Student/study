# 1456. 定长子串中元音的最大数目 —— 题解（基于滑动窗口）

## 一、题目理解

给定：

* 一个只包含小写字母的字符串 `s`
* 一个整数 `k`

我们需要在所有**长度恰好为 k 的子串**中，找出一个子串，使得其中**元音字母个数最多**，并返回这个“最大元音数”。

元音字母是：`a, e, i, o, u`。

本质上就是：

> 在所有长度为 k 的子串里，看看谁的“元音数量”最大。

---

## 二、直观但低效的做法（暴力思路）

最直接的想法：

1. 枚举所有长度为 k 的子串
2. 对每个子串，逐个字符数元音
3. 记录出现过的最大元音个数

如果字符串长度为 `n`：

* 子串个数 ≈ `n - k + 1`
* 每个子串再数 `k` 个字符
* 时间复杂度大约是 `O(k * (n - k + 1))`，最坏可接近 `O(n * k)`

在 `n` 和 `k` 都可能接近 `10^5` 的情况下，这个复杂度是有可能超时的。

我们需要一个更高效的办法。

---

## 三、关键思路：滑动窗口（Sliding Window）

### 1️⃣ 为什么可以用滑动窗口？

题目要求的是**定长 k 的子串**，并且只是统计子串中的某种“计数”（元音数），这非常适合用滑动窗口：

* 窗口大小固定为 `k`
* 每次把窗口右移一格，相当于：

  * **丢掉**窗口左端的一个字符
  * **加入**窗口右端的一个新字符
* 元音数量的变化也只与这两个字符有关

只要我们在移动窗口时“维护当前窗口内的元音数量”，就可以做到：
每次移动窗口，只需要 O(1) 的时间更新元音数。

### 2️⃣ 用滑动窗口具体做什么？

我们维护三个变量：

* `tempCount`：当前窗口中元音的数量（“临时计数”）
* `maxCount`：到目前为止遇到的最大元音数量
* 左指针 `l`，右指针 `r` 用来表示窗口 `[l, r]`

算法过程：

1. **先算出第一个窗口 [0, k-1] 内的元音数量**

   * 将这个数量赋值给 `tempCount`
   * 同时更新 `maxCount = tempCount`
2. 之后我们每次让窗口向右滑动一格：

   * 新窗口是 `[l+1, r+1]`
   * 右边新进来的字符：若是元音，则 `tempCount++`
   * 左边划出的字符：若是元音，则 `tempCount--`
   * 每滑动一次，就更新一次 `maxCount = max(maxCount, tempCount)`

整个过程中，我们从左到右只扫了一遍字符串，每一步都只做常数操作，时间复杂度变成了：

> **O(n)**

---

## 四、结合你代码的细节说明

你的代码结构大致如下（只讲逻辑，不贴代码）：

1. 使用一个 `set<char>` 存储元音集合：`{'a','e','i','o','u'}`，方便用 `find` 判断当前字符是不是元音。

2. 维护变量：

   * `n`：字符串长度
   * `l`：左指针（窗口左端）
   * `r`：右指针（窗口右端，从 `k-1` 开始）
   * `maxCount`：当前遇到的最大元音数量
   * `tempCount`：当前窗口的元音数量

3. 外层循环：`r` 从 `k-1` 一直走到 `n-1`，同时 `l` 每次自增 1
   每次循环代表一个长度为 k 的窗口 `[l, r]`。

4. 当 `l == 0` 时，说明这是**第一个窗口 [0, k-1]**：

   * 单独用一个小循环 `i` 从 `0` 到 `k-1`
   * 遍历第一个窗口内的字符，如果是元音，就让 `maxCount++`
   * 第一个窗口完成后，让 `tempCount = maxCount`
     （此时第一个窗口的元音数就记录完成）

5. 当 `l > 0` 时，说明窗口开始**向右滑动**：

   * 新进入窗口的字符是 `s[r]`，如果是元音，就让 `tempCount++`
   * 划出窗口的字符是 `s[l - 1]`，如果是元音，就让 `tempCount--`
   * 这一步就完成了“窗口移动后的元音计数更新”

6. 每一步滑动后，都更新最大值：

   > `maxCount = max(maxCount, tempCount)`

7. 最终返回 `maxCount`，就是所有长度为 `k` 的子串中，元音数最多的那一个的元音数量。

---

## 五、复杂度分析

* 时间复杂度：

  * 外层循环遍历每个窗口右端 `r`，最多 `n` 次
  * 每次移动窗口只做 O(1) 的加减操作
  * 总体时间复杂度为 **O(n)**

* 空间复杂度：

  * 使用了一个 `set<char>` 保存 5 个元音
  * 其余只是几个整型变量
  * 空间复杂度为 **O(1)**（忽略常数级集合）

---

## 六、总结

这道题的本质是：

> 在一个字符串中，用**固定长度为 k 的滑动窗口**，维护“当前窗口内元音字符的数量”，并在所有窗口中取一个最大值。

整个过程只需要：

1. 初始化第一个长度为 k 的窗口，统计其中元音数；
2. 窗口向右滑动，每次只根据**进来一个字符**和**出去一个字符**调整当前计数；
3. 不断更新全局最大值。

这样就实现了用 **线性时间 O(n)** 解决问题，比枚举每个子串再数元音的暴力解法高效得多，也非常适合处理本题 `10^5` 级别的输入规模。

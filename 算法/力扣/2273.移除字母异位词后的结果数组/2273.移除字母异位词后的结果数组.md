# 2273.移除字母异位词后的结果数组

## 一、题目理解

题目要求我们从一个字符串数组 `words` 中**移除相邻的字母异位词（Anagrams）**。
即如果存在相邻的两个字符串 `words[i-1]` 和 `words[i]` 是异位词（字母重排后相同），则删除 `words[i]`。
这个过程会一直持续，直到数组中不存在相邻异位词为止。

最终结果是剩下的字符串序列（顺序保持不变）。

---

## 二、思路分析

要判断两个字符串是否为**字母异位词**，最直接的方法就是比较它们排序后的结果。

例如：

* `"baba"` 排序后是 `"aabb"`
* `"abba"` 排序后是 `"aabb"`
  → 它们是异位词。

---

### ✅ 关键思路

1. **预处理排序版数组**

   * 创建一个数组 `sorted_words`，将每个 `words[i]` 的字母排序后存入。
   * 这样比较异位词只需要直接比较两个排序后的字符串是否相等。

2. **遍历并过滤**

   * 从第一个字符串开始加入结果。
   * 从第二个字符串开始，如果 `sorted_words[i] != sorted_words[i-1]`，说明它与前一个字符串不是异位词，则将其加入结果。
   * 否则跳过（即删除 `words[i]`）。

3. **不需要真的删除原数组元素**

   * 因为每一步的结果仅依赖于“上一个保留下来的字符串”，并不会改变原下标顺序。
   * 因此只需线性扫描一遍即可完成。

---

## 三、例子推导

以示例 1 为例：

```
输入：
["abba","baba","bbaa","cd","cd"]
```

1. 排序后得到：

   ```
   ["aabb","aabb","aabb","cd","cd"]
   ```
2. 从前向后扫描：

   * 第一个 `"aabb"` → 保留 `"abba"`
   * 第二个 `"aabb"` → 与上一个相同 → 删除 `"baba"`
   * 第三个 `"aabb"` → 与上一个相同 → 删除 `"bbaa"`
   * 第四个 `"cd"` → 与上一个不同 → 保留 `"cd"`
   * 第五个 `"cd"` → 与上一个相同 → 删除
3. 最终结果：

   ```
   ["abba", "cd"]
   ```

---

## 四、算法特性

* **时间复杂度**：
  对每个字符串排序 `O(L log L)`（L ≤ 10），
  对所有字符串线性扫描 `O(n)` → 总体约 `O(n * L log L)`，
  在本题约束（n ≤ 100）下完全可行。

* **空间复杂度**：
  额外存储一个排序后的字符串数组 `O(n * L)`。

---

## 五、总结

| 步骤    | 方法          | 说明                |
| ----- | ----------- | ----------------- |
| 判断异位词 | 排序字符串       | 直接比较排序后的结果        |
| 删除逻辑  | 一次线性扫描      | 只保留与上一个非异位词不同的字符串 |
| 核心思想  | **排序 + 滤重** | 异位词的排序形式相同        |

> 💡 简洁总结：
> **“排序归一化 + 相邻去重”**
> 是解决相邻异位词问题的标准思路。

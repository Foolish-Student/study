# 42.接雨水

给定一个数组 `height`，表示每根柱子的高度，每根柱子宽度为 1。求在这些柱子排列下雨之后能够接到的总雨水量。

例如，对于柱子 `[0,1,0,2,1,0,1,3,2,1,2,1]`，下雨后能够接水的总量为 6。

---

## 思路

这个问题可以抽象为：**每个柱子上方能接水的高度由左右两侧最高柱子决定**。核心思想是“低洼积水”，雨水的高度取决于左右围墙的最小高度减去当前柱子高度。

### 步骤拆解

1. **计算每列左边的最高柱子**

   * 对于数组中的每一列 `i`，求其左边的柱子（不包括自身）的最大高度。
   * 用数组 `max_left[i]` 记录每列左边的最高柱子。
   * 更新方式：`max_left[i] = max(max_left[i-1], height[i-1])`

     * 这里 `max_left[i-1]` 是前一列左边的最高柱子，`height[i-1]` 是前一列的高度。两者取较大值即可。

2. **计算每列右边的最高柱子**

   * 类似地，对每列 `i`，求其右边柱子（不包括自身）的最大高度。
   * 用数组 `max_right[i]` 记录。
   * 更新方式：`max_right[i] = max(max_right[i+1], height[i+1])`

     * 从右向左遍历，保证每列右边的最高柱子被正确计算。

3. **计算每列可接雨水高度**

   * 对于每列 `i`，雨水高度为 `min(max_left[i], max_right[i]) - height[i]`。
   * 如果 `min(max_left[i], max_right[i])` 小于或等于 `height[i]`，说明无法积水，此时高度为 0。
   * 将每列的积水高度累加，即得到总接水量。

### 优化点

* 预处理左右最高柱子数组 `max_left` 和 `max_right`，避免每列都去重新遍历计算，这样时间复杂度由 O(n²) 降低为 O(n)。
* 注意 **左右最高柱子不包括当前柱子本身**，否则会导致积水高度计算错误。

### 总结

* 问题核心：每个柱子上方能积水的高度 = 左右最高柱子中较矮的那个 - 当前柱子高度。
* 使用两个辅助数组记录左右最高柱子，避免重复计算。
* 遍历每列累加即可求出总雨水量。
* 时间复杂度：O(n)，空间复杂度：O(n) 用于存储左右最高柱子数组。

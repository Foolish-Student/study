# P3916 图的遍历

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，令 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。现在请求出 $A(1),A(2),\dots,A(N)$ 的值。

## 输入格式

第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。

接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\dots,N$ 编号。

## 输出格式

一行 $N$ 个整数 $A(1),A(2),\dots,A(N)$。

## 输入输出样例 #1

### 输入 #1

```
4 3
1 2
2 4
4 3
```

### 输出 #1

```
4 4 3 4
```

## 说明/提示

- 对于 $60\%$ 的数据，$1 \leq N,M \leq 10^3$。
- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^5$。


## 题解
### 核心想法：反图 + 从大到小“灌色”

原题要的是：对每个点 $v$，求它**能到达**的点中**编号最大的**那个 $A(v)$。

与其从每个点出发往“更大编号”找，不如**倒过来想**：
若把所有边反向（原图 $u\to v$ 变成反图 $v\to u$），那么“从点 $i$ 在反图里能到达的所有点”，恰好就是“原图中**能够到达 $i$** 的所有点”。
因此如果我们按 **$i = N, N-1, \dots, 1$** 的顺序，在**反图**上从 $i$ 做一次遍历，把能到的所有点的答案都标记为 $i$，就等价于把“最大编号 $i$”这块标签**向所有能到 $i$ 的点**扩散。这样每个点最后得到的就是它所能到达的最大编号。

> 这就是所谓的“**从大到小灌色**”——大编号先占坑，小编号后面就算再碰到这个点，也不会有更大的答案去覆盖它。

---

### 具体做法（与示例代码一致的逻辑）

1. **建反图**：把每条输入边 $u\to v$ 存成 $v\to u$。
2. 准备数组 `res[]`，初始全 0，表示“还没确定”。
3. 依次从 **$i=N$ 到 $1$**：

    * 在反图上从点 $i$ 开始 DFS/BFS，把所有尚未确定答案的点 `x` 的 `res[x]` 赋成 `i`。
    * 若 `res[x]` 已非 0，说明此前已经被更大的编号染过，不再进入，保证每点只处理一次。
4. 输出 `res[1..N]`。

这与“从每个点出发找最大编号”是**等价**的，但避免了重复搜索。

---

### 正确性直觉

* 我们从最大的编号 $N$ 开始，在反图上把“能从 $N$ 到到的点”全部染成 $N$。这些点在原图里都能到达 $N$，所以它们的答案至少是 $N$，而且 $N$ 已经是全图最大，**一定最优**。
* 接着处理 $N-1$。能到达 $N-1$ 的点里，凡是还能到 $N$ 的，**早就被 $N$** 染过了；剩下没被染过的点，说明它们到不了更大的编号，只能到 $N-1$ 及以下，此时把它们染成 $N-1$ 正合适。
* 依此类推，到编号越小，能被它“首次染到”的只会是**达不到任何更大编号**的点，赋值为当前编号就是它们的最大可达编号。

---

### 复杂度分析

* 每个点最多被染一次，每条反向边最多被扫一次，总复杂度 **$O(N+M)$**。
* 空间复杂度 $O(N+M)$（存反图 + 结果数组）。

---

### 边界与细节

* **自环/重边**：不影响结果；染色时第一次确定即停止，重边只会被跳过。
* **不连通**：某些点既到不了别人，也没人能到它，它至少能到自己，所以最终值会是它本身的编号。
* **无需单独 `vis`**：`res[x] != 0` 就是“已经确定”的标记，既当访问标记又当答案缓存。

---

### 为什么循环是 `for (i = N; i >= 1; --i)`，而**不是**到 0？

1. **题目编号是 1…N**：不存在编号 0 的点，去处理 0 没任何意义。
2. **从大到小的顺序是关键**：保证**先**用更大的编号去“占坑”，后面的小编号不会把已确定的更优答案覆盖。
3. **`res` 的初值是 0**：用 0 区分“未确定/未访问”，一旦被某个 $i$ 染色，`res[x]` 变成正数，后续更小的 $i$ 就不会再进入，保证线性复杂度。

---

### 小提示

* 若用递归 DFS，最坏深度可能很大（链式图），本地/评测机栈小会爆栈。可改用显式栈或 BFS，**思想不变**。
* 若坚持递归，可增大栈空间；但更稳妥的是用非递归遍历，避免潜在的 `SIGSEGV`。

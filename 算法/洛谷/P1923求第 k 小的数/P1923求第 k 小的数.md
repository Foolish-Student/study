# 题解：第 k 小元素（快速选择，双向扫描+“挖坑/搬轴”写法）

**问题**
给定长度为 `n` 的数组与整数 `k`（本题代码按 **0-based**：`k ∈ [0, n-1]`），求数组的第 `k` 小元素（不要求稳定排序）。

---

## 思路与算法

采用 **Quickselect（快速选择）**：与快速排序类似，但每次分区后**只递归到包含第 k 小的那一侧**，平均时间复杂度 **O(n)**，最坏 **O(n²)**，空间 **O(1)**。

本题用的是一种\*\*双向扫描 + 搬轴（等价于“挖坑填数”）\*\*的分区写法：

* 选枢轴 `pivot = a[l]`（先把它“挖出来”暂存在变量里）。
* 设双指针 `i=l, j=r`。
* 循环直到 `i == j`：

    1. 让 `j` 从右往左找第一个 `<= pivot` 的元素；把它“搬”到左边空位：`swap(a[i], a[j]); i++`
    2. 让 `i` 从左往右找第一个 `>= pivot` 的元素；把它“搬”到右边空位：`swap(a[i], a[j]); j--`
    3. 两步交替，**pivot 在交换对中来回“被搬运”**，左右区逐渐收缩
* 退出时 `i==j` 是 pivot 的最终位置 `p`，再执行 `a[p] = pivot`（把枢轴值放回）。
* 若 `k == p` 直接返回；若 `k < p` 递归左半；否则递归右半。

> 这里比较符号选用 `a[j] > pivot` 与 `a[i] < pivot`（严格号），能避免重复值卡住；交换后推进对应指针，保证收敛。

---

## 正确性要点（不写长证，只给不变量）

* 循环过程中保持不变量：

    * 左侧已确定区 **`[l, i-1]`** 均 **`<= pivot`**
    * 右侧已确定区 **`[j+1, r]`** 均 **`>= pivot`**
    * 枢轴值保存在变量 `pivot` 中（期间通过交换在 `i/j` 处“搬运”），不丢失
* 当指针相遇 `i==j`，该位置正是把 `pivot` 放回去后满足“左 ≤ pivot ≤ 右”的唯一合法位置。

---

## 复杂度

* 平均时间 **O(n)**（每轮分区是线性的，只递归一侧）
* 最坏时间 **O(n²)**（例如始终选到极端枢轴；可用“随机/三数取中”缓解）
* 额外空间 **O(1)**（原地分区）

---

## 易错点与小优化

* **k 的基准**：当前写法是 **0-based**。若题面给的是第 `1..n` 小，需在读取后 `--k`。
* **重复元素**：比较符号用严格号（`> / <`）并在交换后推进对应指针，防止停滞。
* **最坏情况**：如数据接近有序、枢轴总选极端。可将 `pivot` 改为“三数取中”（`a[l], a[(l+r)/2], a[r]` 取中位）或随机选，降低退化概率。
* **I/O**：大数据建议用 `scanf/printf` 或 `ios::sync_with_stdio(false); cin.tie(nullptr);` 加速。


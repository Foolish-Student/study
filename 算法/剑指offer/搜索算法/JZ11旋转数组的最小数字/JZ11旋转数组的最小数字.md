# 题解：旋转数组的最小数字（JZ11）

## 一、题目理解

题目给定一个非降序数组（可能有重复元素）`nums`，将其旋转后得到一个旋转数组，例如：

* `[1,2,3,4,5]` → `[3,4,5,1,2]`
* `[1,2,3,4,5]` → `[4,5,1,2,3]`

要求在 **O(log n)** 时间复杂度下找到旋转数组中的最小值。

**特点**：

1. 数组原本非降序，但旋转后可能出现前大后小的情况（`nums[mid] > nums[right]`）。
2. 数组可能包含重复元素（如 `[3,100,200,3]`），可能导致二分时无法确定最小值方向。
3. 空间复杂度要求 O(1)。

---

## 二、解题思路

这个问题是**典型的旋转有序数组二分查找最小值问题**。关键是利用二分法不断缩小搜索区间，找到最小元素。

1. 初始化两个指针：

```cpp
int left = 0;
int right = nums.size() - 1;
```

2. 使用 **左闭右闭区间** `[left, right]` 进行二分：

```cpp
while (left < right) {
    int mid = left + (right - left) / 2;
}
```

> 注意：循环条件用 `<` 而非 `<=`，保证当 `left == right` 时循环退出，最小值就在 `nums[left]` 或 `nums[right]`。

3. 比较 `nums[mid]` 与 `nums[right]` 的大小，分三种情况处理：

### 情况 1：`nums[mid] > nums[right]`

* 表示最小值在 **右半区间**（不包含 mid，因为 mid 大于 right）
* 移动左指针：

```cpp
left = mid + 1;
```

### 情况 2：`nums[mid] < nums[right]`

* 表示最小值在 **左半区间**（可能是 mid 本身）
* 移动右指针：

```cpp
right = mid;
```

### 情况 3：`nums[mid] == nums[right]`

* 出现重复元素，无法确定最小值在哪一边
* 缩小搜索区间，`right--` 逐步排除重复元素：

```cpp
right--;
```

---

## 三、循环退出条件

* 当 `left == right` 时，搜索区间缩小到一个元素
* 这个元素就是旋转数组中的最小值

```cpp
return nums[right]; // 或 nums[left]
```

---

## 四、算法分析

| 项目    | 分析                                                           |
| ----- | ------------------------------------------------------------ |
| 时间复杂度 | O(log n) 平均情况；最坏情况 O(n)（当数组元素大量重复时，每次只能 `right--`，退化为线性扫描）   |
| 空间复杂度 | O(1)                                                         |
| 核心技巧  | 利用二分法缩小搜索区间，根据 mid 与 right 的比较判断最小值方向；处理重复元素需要特殊处理 `right--` |

---

✅ **总结**：

* 本题是旋转数组最小值的经典二分查找问题
* 循环条件 `while(left < right)`，退出时 `left == right`
* 根据 `nums[mid]` 与 `nums[right]` 的关系移动左右指针
* 处理重复元素时，可能退化为 O(n)，但平均情况下仍为 O(log n)
* 返回 `nums[left]` 或 `nums[right]` 即可

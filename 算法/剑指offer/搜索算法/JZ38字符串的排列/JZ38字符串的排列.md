# 题解：字符串的全排列（JZ38）

**题目回顾：**
给定一个长度不超过 10 的字符串，要求返回该字符串中所有字符的排列组合。输入字符可能包含重复字符，输出要求去重，顺序可以任意。

例如：

* 输入 `"ab"` → 输出 `["ab", "ba"]`
* 输入 `"aab"` → 输出 `["aab", "aba", "baa"]`

---

##解题思路

1. **全排列的核心思想**
   全排列问题的核心是 **递归和回溯**。
   对于长度为 n 的字符串，每个字符都可以放在排列的第 1 个位置，然后递归处理剩下的 n-1 个字符，依次类推。

   * 对于字符串 `"ABC"`，排列过程可以理解为：

     1. 选择 `'A'` 作为首位 → 剩下 `'B'` `'C'` 进行递归排列 → 得到 `"ABC"` 和 `"ACB"`
     2. 选择 `'B'` 作为首位 → 剩下 `'A'` `'C'` → 得到 `"BAC"` 和 `"BCA"`
     3. 选择 `'C'` 作为首位 → 剩下 `'A'` `'B'` → 得到 `"CAB"` 和 `"CBA"`

   这种方式自然生成了所有可能的排列。

2. **递归与回溯实现**

   * **递归参数**：

     * 当前生成的字符串 `res`
     * 已使用字符的标记数组 `vis`（长度与输入字符串相同，标记哪些字符已经使用）
     * 当前递归深度 `n`，表示 `res` 中已有字符数量

   * **递归出口**：
     当 `res` 的长度等于原始字符串长度时，将 `res` 加入结果集合。

   * **回溯步骤**：
     遍历输入字符串的每一个字符：

     1. 如果当前字符未使用（`vis[i] == 0`），则将其加入 `res` 并标记为已使用。
     2. 递归处理下一个位置。
     3. 递归返回后，撤销选择（回溯），将字符标记为未使用，尝试下一个字符。

3. **去重处理**
   当输入字符串包含重复字符时，例如 `"aab"`，如果直接递归，会生成重复排列。

   * 使用 **集合 (`set`)** 来存储生成的排列，可以自动去重。
   * 最终将集合转换为数组返回。

4. **复杂度分析**

   * **时间复杂度**：`O(n!)`
     每个字符都有 n 个位置需要尝试，总排列数量为 n!，生成每个排列需要 O(n) 时间用于拼接字符串，总体复杂度仍是阶乘级。
   * **空间复杂度**：`O(n!)`
     存储所有排列的集合需要额外空间；递归栈深度为 O(n)。

5. **特点与注意事项**

   * 回溯法是一种 **“选择-递归-撤销选择”** 的典型模式。
   * 使用标记数组可以避免重复使用字符。
   * 当输入长度较小（n < 10）时，递归回溯法非常高效。
   * 最终用集合去重可以解决输入中包含重复字符的情况。

---

**总结：**

本题的解决方案可以总结为四步：

1. **初始化**：空字符串 `res`，标记数组 `vis` 全为 0。
2. **递归生成**：从第 0 个字符开始，每次选择未使用字符加入 `res`。
3. **回溯**：递归结束后撤销选择，尝试下一字符。
4. **去重与输出**：使用集合存储结果，避免重复排列，最后转换为数组返回。

这种方法通俗易懂，递归逻辑清晰，且能够处理重复字符的去重问题，是解决全排列问题的标准做法。

# 题解：二维数组中的查找（JZ4）

## 题目理解

题目给定一个 **二维矩阵 `array`**，满足如下特性：

1. 每行元素从左到右严格递增。
2. 每列元素从上到下严格递增。

要求输入一个整数 `target`，判断该矩阵中是否存在这个元素。

示例：

```
matrix = [
 [1, 2, 8, 9],
 [2, 4, 9,12],
 [4, 7,10,13],
 [6, 8,11,15]
]
target = 7 → true
target = 3 → false
```

矩阵最大尺寸为 **500 × 500**，矩阵中的元素范围 0 ≤ val ≤ 10^9。

进阶要求：

* **时间复杂度 O(n + m)**
* **空间复杂度 O(1)**

---

## 解题思路

这个矩阵同时满足 **行递增** 和 **列递增** 的性质，可以利用这一特性从矩阵的 **右上角或左下角** 开始查找。

### 1️⃣ 从右上角查找

1. 初始化位置 `(i, j)`：

   * `i = 0`（第一行）
   * `j = m - 1`（最后一列）
2. 比较 `array[i][j]` 与 `target`：

   * 若相等 → 找到，返回 true
   * 若 `array[i][j] > target` → 当前元素太大，移动到左边，即 `j--`
   * 若 `array[i][j] < target` → 当前元素太小，移动到下一行，即 `i++`
3. 重复上述步骤，直到越界：

   * 如果 `i == n` 或 `j < 0` → 没找到，返回 false

**为什么从右上角（或左下角）开始？**

* 右上角元素是当前列最大、当前行最小的元素：

  * 大于目标 → 可以排除当前列
  * 小于目标 → 可以排除当前行
* 左下角同理（当前行最大，当前列最小）

这样每次移动 **一行或一列**，总共最多走 `n + m` 步 → **时间复杂度 O(n + m)**。

### 2️⃣ 复杂度分析

* **时间复杂度 O(n + m)**

  * 最坏情况：每行或每列最多走一遍
* **空间复杂度 O(1)**

  * 只使用了两个变量保存当前位置 `(i, j)`

### 3️⃣ 特殊情况处理

1. **矩阵为空**：`n == 0` 或 `m == 0` → 直接返回 false
2. **单行/单列矩阵**：算法依然适用
3. **矩阵中存在重复元素**：算法依然适用，只要找到一个就返回 true

---

## 总结

* **关键点**：利用矩阵的行递增、列递增性质，从右上角或左下角开始，逐行或逐列排除不可能的元素
* **核心思路**：

  1. 当前位置比 target 大 → 向左
  2. 当前位置比 target 小 → 向下
  3. 相等 → 返回 true
* **优点**：时间复杂度 O(n + m)，空间复杂度 O(1)，比暴力枚举 n × m 快得多
* **常见错误**：

  * 从左上角或右下角直接遍历 → 无法一步步排除行/列
  * 使用二分查找逐行搜索 → 时间复杂度 O(n log m)，虽好但不是最优解


## JZ53 笔记：数字在升序数组中出现的次数

### 题目概述

* **输入**：一个长度为 `n` 的 **非降序数组** `nums` 和一个非负整数 `k`

* **输出**：统计 `k` 在数组中出现的次数

* **要求**：

  * 时间复杂度：`O(log n)` → 二分查找
  * 空间复杂度：`O(1)` → 不使用额外数组

* **例子**：

  1. `nums = [1,2,3,3,3,3,4,5], k = 3` → 返回 `4`
  2. `nums = [1,3,4,5], k = 6` → 返回 `0`

---

### 方法分析

**核心思路**：
利用 **二分查找** 找到 `k` 的 **第一次出现位置** 和 **最后一次出现位置**，然后用公式计算次数：

$$
\text{count} = \text{lastIndex} - \text{firstIndex} + 1
$$

如果 `firstIndex > lastIndex`，说明数组中不存在 `k`。

---

### 函数设计

#### 1️⃣ `FirstIndex(nums, k)`

* **目标**：找到 `k` 第一次出现的索引
* **逻辑**：

  * 初始化 `left = 0, right = n-1`
  * 循环条件 `while(left <= right)`：

    1. 计算 `mid = (left + right)/2`
    2. 如果 `nums[mid] < k` → `left = mid + 1`（左边界右移）
    3. 否则 → `right = mid - 1`（缩小右边界）
* **返回**：`left`，即第一个大于等于 `k` 的位置

**小结**：`FirstIndex` 找到数组中**第一个 ≥ k 的位置**。

---

#### 2️⃣ `LastIndex(nums, k)`

* **目标**：找到 `k` 最后一次出现的索引
* **逻辑**：

  * 初始化 `left = 0, right = n-1`
  * 循环条件 `while(left <= right)`：

    1. 计算 `mid = (left + right)/2`
    2. 如果 `nums[mid] <= k` → `left = mid + 1`（左边界右移，保证找到最后一个 k）
    3. 否则 → `right = mid - 1`（缩小右边界）
* **返回**：`right`，即最后一个 ≤ k 的位置

**小结**：`LastIndex` 找到数组中**最后一个 ≤ k 的位置**。

---

#### 3️⃣ `GetNumberOfK(nums, k)`

* **逻辑**：

  1. 调用 `FirstIndex` 得到 `first`
  2. 调用 `LastIndex` 得到 `last`
  3. 判断 `first > last` → `k` 不存在 → 返回 0
  4. 返回 `last - first + 1` → `k` 出现次数

---

### 二分查找边界分析

| 函数         | 条件               | 更新               | 返回值                |
| ---------- | ---------------- | ---------------- | ------------------ |
| FirstIndex | `nums[mid] < k`  | `left = mid + 1` | `left` → 第一个 ≥ k   |
| LastIndex  | `nums[mid] <= k` | `left = mid + 1` | `right` → 最后一个 ≤ k |

> 注意：二分查找中 **左边界更新要 +1，右边界更新要 -1**，否则可能出现死循环或无限重复。

---

### 时间复杂度分析

* `FirstIndex` → `O(log n)`
* `LastIndex` → `O(log n)`
* 统计次数 → `O(1)`

**总复杂度**：`O(log n)`（满足题目要求）

* 空间复杂度：`O(1)`（只用了一些整数变量，不依赖额外数组）

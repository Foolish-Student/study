# JZ3数组中重复的数字

## 题目概述

给定一个长度为 `n` 的数组 `numbers`，数组中的每个元素都在 `[0, n-1]` 的范围内。数组中某些数字可能重复，但不清楚重复了多少次，也不清楚有几个重复的数字。要求找出数组中任意一个重复数字，如果输入不合法则返回 `-1`。

示例：

* 输入 `[2,3,1,0,2,5,3]`，输出 `2` 或 `3` 均正确。

---

## 解题思路

这道题的核心在于**利用数组元素的值和下标的映射关系**，实现**O(n) 时间复杂度和 O(1) 空间复杂度**的解决方案：

1. **遍历数组**：

   * 遍历每个下标 `i`。
   * 如果当前元素 `numbers[i]` 等于下标 `i`，说明这个数字已经在正确位置，不需要操作，直接跳到下一个下标。

2. **检查重复**：

   * 如果当前元素 `numbers[i]` 不等于下标 `i`，则判断它应放置的位置 `numbers[numbers[i]]` 是否等于当前数字。
   * 如果相等，说明已经有一个相同的数字在它应该在的位置上，这就是重复数字，可以直接返回。

3. **交换元素**：

   * 如果没有重复，则将当前数字 `numbers[i]` 与它应该在的位置 `numbers[numbers[i]]` 交换，使数字尽量放到对应下标上。
   * 交换后不增加下标 `i`，再次判断当前位置的数字，直到找到重复或者当前位置数字放置正确。

4. **终止条件**：

   * 遍历完整个数组，如果没有找到重复数字，则返回 `-1`，说明输入不合法。

---

## 算法特点

* **时间复杂度**：O(n)
  每个元素最多交换一次，遍历一次数组即可找到重复数字。
* **空间复杂度**：O(1)
  只使用原数组进行交换，不需要额外存储空间。
* **适用范围**：数组元素必须在 `[0, n-1]` 范围内，否则算法不保证正确性。

---

## 核心思想

1. **元素与下标对应**：利用“值即索引”的特性，将数字放在其对应下标位置。
2. **发现重复**：当目标下标位置已有相同数字时，即可判定重复。
3. **原地交换**：无需额外空间，通过交换将数字放到对应位置，使算法高效且节省内存。

> 这种方法巧妙地将数组当作哈希表使用，保证了 O(n) 时间和 O(1) 空间，是处理数字范围已知且在 `[0,n-1]` 内数组重复问题的经典技巧。

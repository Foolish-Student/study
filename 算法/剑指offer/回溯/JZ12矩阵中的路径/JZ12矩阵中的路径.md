# JZ12矩阵中的路径

## 题目概述

* 给定一个 n × m 的字符矩阵 `matrix`，以及一个字符串 `word`
* 路径规则：

  1. 可以从矩阵任意格子开始
  2. 每次可以向左、右、上、下移动一格
  3. 一条路径中 **同一个格子不能重复访问**
* 目标：判断矩阵中是否存在一条路径包含字符串 `word` 的所有字符

示例：

| matrix                                                      | word     | 返回值   |
| ----------------------------------------------------------- | -------- | ----- |
| \[\["a","b","c","e"],\["s","f","c","s"],\["a","d","e","e"]] | "abcced" | true  |
| \[\["a","b","c","e"],\["s","f","c","s"],\["a","d","e","e"]] | "abcb"   | false |

---

## 解题思路

### 1️⃣ DFS（深度优先搜索）

* 核心思想：**从每个可能的起点开始尝试搜索路径**
* 每一步尝试匹配字符串的当前字符，并递归向四个方向搜索
* **访问标记**：用一个二维数组 `vis` 标记格子是否被访问，保证同一条路径不重复经过同一个格子

---

### 2️⃣ 起点选择

* 遍历矩阵的每个格子
* 只有当矩阵格子字符等于字符串的首字符时，才尝试从该格子开始 DFS
* 这样减少不必要搜索，提高效率

---

### 3️⃣ DFS 搜索逻辑

* 当前格子匹配字符串中的第 `count` 个字符
* 对四个方向进行尝试：

  1. 判断新位置是否在矩阵范围内
  2. 判断新位置是否未被访问
  3. 判断新位置字符是否匹配字符串的下一个字符
* 如果满足条件：

  * 标记该格子已访问
  * 递归搜索下一个字符
  * 回溯：搜索结束后取消访问标记（恢复状态）

---

### 4️⃣ 回溯（Backtracking）

* 每条路径尝试结束后，需要 **回溯**：

  * 将当前格子 `vis[y][x]` 重置为未访问
* 回溯保证：

  * 下一条尝试路径可以重新经过该格子
  * 不影响其他搜索分支

---

### 5️⃣ 终止条件

* 当 DFS 到达字符串末尾（匹配了最后一个字符） → 返回 true
* 如果所有可能路径尝试完毕仍未匹配 → 返回 false

---

### 6️⃣ 复杂度分析

* **时间复杂度**：O(n \* m \* 4^len)

  * 每个格子可能作为起点
  * 每步尝试四个方向
  * 最坏情况下，搜索长度为字符串长度 `len`
* **空间复杂度**：O(n \* m)

  * 访问标记矩阵 `vis`
  * 递归栈深度最大为 `len`

---

### 7️⃣ 核心总结

* **起点遍历 + DFS + 回溯** 是解决矩阵路径问题的经典策略
* **访问标记数组**保证每条路径不重复经过同一个格子
* **剪枝优化**：

  * 只有首字符匹配时才开始 DFS
  * 匹配失败立即回溯

---

💡 **一句话概括**：

> **“从每个可能起点 DFS，四方向尝试，匹配字符，回溯恢复状态，找到路径即返回 true。”**
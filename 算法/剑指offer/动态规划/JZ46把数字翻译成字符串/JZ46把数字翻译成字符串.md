# JZ46 题解｜把数字翻译成字符串

## 题目

### 描述

有一种将字母编码成数字的方式：`'a' -> 1, 'b' -> 2, ..., 'z' -> 26`。

给定一串数字，返回有多少种可能的译码结果。

* **输入**：一个数字串 `nums`，其中每个字符表示一个数字，长度满足 `0 < n ≤ 90`。
* **输出**：返回该数字串可能的译码方式总数。

### 示例

* 示例1：

  * 输入：`"12"`
  * 输出：`2`
  * 说明：有 2 种可能的译码结果："ab" 或 "l"。
* 示例2：

  * 输入：`"31717126241541717"`
  * 输出：`192`
  * 说明：有 192 种可能的译码结果。

---

## 一、问题本质与建模

题目要求将数字串转换为字母，这类似于**数字转字母**问题。对于每个数字组合，可以选择将它作为一个单独的数字进行翻译，或者将它与前一个数字组合成一个两位数进行翻译。

### 状态转移分析

我们需要知道每个位置 `i`（从 1 开始）前面有多少种解码方式。可以通过动态规划来解决：

1. **状态定义**：
   设 `dp[i]` 为从第 1 个字符到第 `i` 个字符的解码方式总数。

2. **状态转移**：

   * **单字符翻译**：如果 `nums[i-1]` 不为 `0`，则可以翻译成一个字母，`dp[i] += dp[i-1]`。
   * **双字符翻译**：如果 `nums[i-2]` 和 `nums[i-1]` 组合成一个有效的数字（即 10 ≤ 组合数字 ≤ 26），则可以翻译成一个字母，`dp[i] += dp[i-2]`。

3. **边界条件**：

   * `dp[0] = 1`：表示空字符串只有 1 种翻译方式（即不翻译）。
   * `dp[1] = 1`：表示只有一个字符时，有且只有一种翻译方式。

---

## 二、解法路线（从易到优）

### 1）递归（不推荐）

递归的时间复杂度为 O(2^n)，会重复计算大量子问题，时间效率低，容易超时。

### 2）记忆化 / DP 表（推荐）

通过动态规划来解决，记录每个子问题的解，避免重复计算：

* 定义 `dp[i]` 为数字串 `nums[0..i-1]` 的译码方式数。
* 初始化：`dp[0] = 1`（空字符串），`dp[1] = 1`（单个字符的情况）。
* 递推：根据当前数字和前一个数字决定是否更新 `dp[i]`。

### 3）空间优化（进阶）

我们只需要记录前两个状态 `dp[i-1]` 和 `dp[i-2]`，从而节省空间。

* **时间复杂度**：O(n)，因为我们只需要遍历一次字符串。
* **空间复杂度**：O(n) 或 O(1)，优化后的空间复杂度可以达到 O(1)。

---

## 三、复杂度分析

* **时间复杂度**：O(n)，每个字符遍历一次。
* **空间复杂度**：O(n)，使用了动态规划数组 `dp`，不过可以优化至 O(1)。

---

## 四、样例推演

以 `nums = "12"` 为例：

* `dp[0] = 1`，空字符串的翻译方式为 1。
* `dp[1] = 1`，只有一个字符 "1"，只有一种翻译方式。
* `dp[2]`：

  * 单字符 "2" 翻译，`dp[2] += dp[1]`（`dp[2] = 1`）
  * 双字符 "12" 翻译，`dp[2] += dp[0]`（`dp[2] = 2`）

最终 `dp[2] = 2`，即有 2 种翻译方式。

---

## 五、边界与坑点

1. **"0" 单独处理**：若数字串中有单独的 `0`，而前一位不是 `1` 或 `2`，则无法翻译，返回 0。
2. **重复计算问题**：递归时会遇到很多重复子问题，建议用动态规划避免。
3. **输入异常**：如果输入为空字符串，直接返回 0。

---

## 六、一页纸总结

* **建模**：用 `dp[i]` 表示从 1 到 `i` 字符串的解码方式数。
* **状态转移**：`dp[i]` = `dp[i-1]` + `dp[i-2]`，具体判断当前数字是否有效。
* **边界条件**：`dp[0] = 1`，`dp[1] = 1`。
* **实现**：动态规划，自底向上填表。
* **优化**：可以用滚动变量将空间复杂度优化到 O(1)。

> 牢记：**动态规划问题的关键是如何定义状态和状态转移方程。**

# JZ48 题解｜最长不含重复字符的子字符串

## 题目

### 描述

给定一个字符串 `s`，请找出其中**最长的不包含重复字符的子字符串**的长度。

* **输入**：字符串 `s`（`s.length ≤ 40000`）
* **输出**：一个整数，表示最长无重复子串的长度

### 示例

* 示例1：输入 `"abcabcbb"`，输出 `3` （最长子串 `"abc"`）
* 示例2：输入 `"bbbbb"`，输出 `1` （最长子串 `"b"`）
* 示例3：输入 `"pwwkew"`，输出 `3` （最长子串 `"wke"`）

---

## 题解

### 问题分析

这是一个**子串问题**，要求最长不含重复字符的连续子串长度。
关键点在于：**窗口内不能有重复字符**。

我们可以用 **滑动窗口 + 哈希表** 来解决：

* **滑动窗口**：用两个指针维护一个当前子串区间 `[l, r]`；
* **哈希表**：记录窗口中每个字符出现的次数，用来检测是否有重复。

---

### 核心思路

1. 遍历字符串，用右指针 `i` 扩展窗口，把 `s[i]` 加入哈希表；
2. 如果某个字符出现次数 > 1，说明重复，需要移动左指针 `l`，并更新哈希表，直到窗口恢复无重复；
3. 在每一步，窗口长度是 `i - l + 1`，取最大值作为答案。

这样保证窗口 `[l, i]` 始终是不重复的最长子串。

---

### 算法步骤

1. **初始化**：

   * 哈希表 `countChar` 记录字符出现次数
   * 左指针 `l=0`，结果 `maxCount=0`

2. **遍历字符串**：

   * 每次右指针移动，统计当前字符次数
   * 如果重复（次数>1），左指针右移并减去对应字符次数

3. **更新答案**：

   * `maxCount = max(maxCount, i - l + 1)`

---

### 复杂度分析

* **时间复杂度**：O(n)，每个字符进窗口一次、出窗口一次
* **空间复杂度**：O(字符集大小)，对于 ASCII 至多 O(128)，可视为常数

---

### 样例推演

以 `"pwwkew"` 为例：

* i=0, s\[i]=p，窗口=`"p"`，max=1
* i=1, s\[i]=w，窗口=`"pw"`，max=2
* i=2, s\[i]=w，重复！移动左指针到 `"w"`，max=2
* i=3, s\[i]=k，窗口=`"wk"`，max=2
* i=4, s\[i]=e，窗口=`"wke"`，max=3
* i=5, s\[i]=w，重复！调整后窗口=`"ew"`，max=3

最终答案 `3`。

---

### 核心思想总结

* **滑动窗口**：维护一个不重复的子串
* **哈希表**：检测字符是否重复
* **动态更新**：每次扩展右指针后，收缩左指针保持合法性

这是典型的 **双指针 + 哈希表** 问题，套路非常通用。

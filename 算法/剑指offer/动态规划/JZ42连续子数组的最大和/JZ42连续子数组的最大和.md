# JZ42 连续子数组的最大和（笔记＋题解思路）

## 题目概述

* **输入**：长度为 `n` 的整型数组 `array`（`1 ≤ n ≤ 2×10^5`，`-100 ≤ a[i] ≤ 100`）。
* **目标**：从所有“连续子数组”（长度 ≥ 1）中，求**最大子数组和**。
* **要求**：

  * 时间复杂度 **O(n)**
  * 空间复杂度 **O(n)**（基础版）/ **O(1)**（进阶）
* **示例**

  * `[1,-2,3,10,-4,7,2,-5]` → 最大和 `18`（子数组 `[3,10,-4,7,2]`）
  * `[2]` → `2`
  * `[-10]` → `-10`

---

## 一、问题本质与建模

最大子数组和的经典解法是 **Kadane 算法**（可视作一个一维 DP）。

### 状态定义（基础 DP 版）

* 定义 `dp[i]`：**以位置 i 结尾** 的所有子数组中，最大子数组和。

  * “以 i 结尾”很关键：它把“是否延续之前的子数组”这个决策局部化了。

### 状态转移

到达元素 `array[i]` 时有两种选择：

1. **从这里重新开始**子数组：仅取 `array[i]`
2. **把它接在之前的最优尾巴上**：`dp[i-1] + array[i]`
   因此：

> `dp[i] = max(array[i], dp[i-1] + array[i])`

### 结果

> 答案是 `max(dp[i])`（`i` 从 `0..n-1`）

### 初始化

* `dp[0] = array[0]`（以第 0 个结尾的最佳就是它自身）

### 复杂度

* **时间**：一次线性扫描 → **O(n)**
* **空间**：

  * 基础：保存整行 `dp` → **O(n)**
  * 进阶：只需“上一个 `dp[i-1]`”与“全局最大” → **O(1)**（见下）

---

## 二、进阶：O(1) 空间的贪心/滚动思路（Kadane 直观版）

把 `dp[i]` 的定义“滚动”成两个变量：

* `best_end`：当前下标 `i` 处“**以 i 结尾**的最大和”（相当于 `dp[i]`）
* `best_all`：扫描到目前为止的**全局最大**

更新规则与 DP 完全一致，只是把 `dp[i]` 写成滚动变量：

* `best_end = max(array[i], best_end + array[i])`
* `best_all = max(best_all, best_end)`

**直觉**：

* 如果 `best_end` 变成负数，再往后只会拖后腿，下一位直接“重启”。
* 正数就“续航”，把好处传给后面。

---

## 三、为什么转移式是 `max(array[i], dp[i-1] + array[i])`？

这一步是在做**局部决策**：

* 若前缀最佳 `dp[i-1]` 为**负**，再加上 `array[i]` 只会更糟 → **丢掉它，从 i 重新开始**。
* 若为**正**，加上 `array[i]` 会更大 → **延续**。

很多人容易写错成 `max(dp[i-1], dp[i-1] + array[i])`，这等价于“要么不加当前，要么继续加”，**却从不允许“从当前重启”**，在 `[-2, 3]` 这类例子会得到错误答案（应为 `3`，而不是 `1`）。

---

## 四、示例推演（一步到位理解）

以 `[1,-2,3,10,-4,7,2,-5]` 为例（只列关键变量）：

| i | a\[i] | best\_end = max(a\[i], best\_end + a\[i]) | best\_all = max(best\_all, best\_end) |
| - | ----- | ----------------------------------------- | ------------------------------------- |
| 0 | 1     | max(1, 1) = 1                             | 1                                     |
| 1 | -2    | max(-2, 1-2) = -1                         | 1                                     |
| 2 | 3     | max(3, -1+3) = 3                          | 3                                     |
| 3 | 10    | max(10, 3+10) = 13                        | 13                                    |
| 4 | -4    | max(-4, 13-4) = 9                         | 13                                    |
| 5 | 7     | max(7, 9+7) = 16                          | 16                                    |
| 6 | 2     | max(2, 16+2) = 18                         | 18 ← **答案**                           |
| 7 | -5    | max(-5, 18-5) = 13                        | 18                                    |

对应的最优子数组就是在 `best_all` 达到 18 的那段，即 `[3,10,-4,7,2]`。

---

## 五、边界与坑点

* **全负数**：算法自然返回最大元素（因为“重启”为单个元素本身），无需特判。
* **n=1**：答案就是 `array[0]`。
* **易错点**：

  * 写成 `max(dp[i-1], dp[i-1] + a[i])`（忘了“从 i 重启”）
  * `best_all`（或 `ans`）没有用首元素正确初始化，导致全负时出错
* **稳定性**：本题 `a[i]` 在 `[-100, 100]`，整型和不会溢出；若扩展到大范围需考虑更大类型。

---

## 六、如何找出子数组下标（可选拓展）

在滚动过程中，额外维护：

* `start`：当前“候选子数组”的起点；当选择“从 i 重启”时令 `start = i`
* `bestL, bestR`：记录历史最优的左右端点；当 `best_end` 刷新到更大时更新为 `[start, i]`

这样可在 **O(1) 空间、O(n) 时间** 同时得到最大和与其对应区间。

---

## 七、对比“贪心”与“DP”

* 该问题既可视作**DP**（明确状态与转移），也可视作**贪心**（和为负就丢、和为正就续）。
* 本质相同：Kadane 是一个经过证明正确的“贪心＋局部最优”策略，满足**最优子结构**与**无后效性**。

---

### 一页纸总结

* **目标**：最大子数组和
* **核心转移**：`best_end = max(a[i], best_end + a[i])`；`best_all = max(best_all, best_end)`
* **复杂度**：时间 O(n)，空间 O(1)
* **直觉**：负和就丢、正和就续；必要时从当前元素“重启”。

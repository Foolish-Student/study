
# JZ47 题解｜礼物的最大价值（笔记＋题解思路）

## 题目概述

* **输入**：二维数组 `grid[m][n]`（`1 ≤ m, n ≤ 200`，`grid[i][j] > 0`）
* **规则**：

  * 从左上角 `(0,0)` 出发，只能向 **右** 或 **下** 走
  * 每到一个格子，收集该格子的礼物价值
  * 直到右下角 `(m-1, n-1)`
* **目标**：路径上礼物价值之和的最大值
* **复杂度要求**：时间 **O(m·n)**，空间 **O(1)**（可复用原数组）

---

## 一、问题本质与建模

这是一个经典的 **二维动态规划问题**。

考虑走到某个位置 `(i, j)`：

* 只能从 **上方 `(i-1, j)`** 或 **左方 `(i, j-1)`** 过来
* 因此能拿到的最大价值为：

> **`dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])`**

边界情况：

* **第一行**：只能从左边走过来
* **第一列**：只能从上边走过来

最终答案就是 `dp[m-1][n-1]`。

---

## 二、解法路线（从易到优）

### 1）二维 DP 表

建立一个同规模的 `dp[m][n]`，逐行逐列填表。

* 时间复杂度 **O(m·n)**
* 空间复杂度 **O(m·n)**

### 2）原地修改（推荐）

观察转移方程：每次更新只依赖 **左边和上边**，因此我们可以直接在 `grid` 里累加，不需要额外数组：

* `grid[i][j] += max(grid[i-1][j], grid[i][j-1])`
* 节省空间，复杂度依旧是 **O(m·n)** 时间、**O(1)** 额外空间

这正是你的代码采用的方式。

---

## 三、样例推演

输入：

```
[
 [1, 3, 1],
 [1, 5, 1],
 [4, 2, 1]
]
```

推演过程：

1. 第一行累加： `[1, 4, 5]`
2. 第一列累加： `[1, 2, 6]`
3. 逐步更新：

   * (1,1) = 5 + max(1,4) = 9
   * (1,2) = 1 + max(9,5) = 10
   * (2,1) = 2 + max(6,9) = 11
   * (2,2) = 1 + max(10,11) = 12

最终 `grid[2][2] = 12` ✅

---

## 四、复杂度分析

* **时间**：每个格子都计算一次 → O(m·n)
* **空间**：原地更新 → O(1) 额外空间

---

## 五、边界与坑点

1. **单行/单列**：只能一路走直线，需正确初始化
2. **m=1 且 n=1**：答案就是 `grid[0][0]`
3. **必须保证值 > 0**：题目已说明，避免负数干扰转移

---

## 六、一页纸总结

* **建模**：走到 `(i, j)` 只能从上或左来
* **转移**：`dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])`
* **边界**：第一行只能来自左边，第一列只能来自上边
* **结果**：`grid[m-1][n-1]`
* **复杂度**：O(m·n) 时间，O(1) 空间（原地更新）

> 牢记：**二维 DP 网格问题，常见转移方向是“上/左”或者“上/左/斜上”，能原地更新就不额外开表。**


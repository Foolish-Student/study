# JZ70 矩形覆盖

## 题目

### 描述
我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？

数据范围：0 ≤ n ≤ 38

进阶：空间复杂度 O(1)，时间复杂度 O(n)

注意：约定 n == 0 时，输出 0

比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)：

### 输入描述
2*1的小矩形的总个数n

### 返回值描述
覆盖一个2*n的大矩形总共有多少种不同的方法(从同一个方向看)

### 示例
- 示例1：输入 0，返回值 0
- 示例2：输入 1，返回值 1  
- 示例3：输入 4，返回值 5

## 题解

### 问题分析

这是一道经典的动态规划问题。我们需要用 n 个 2×1 的小矩形来覆盖一个 2×n 的大矩形。

关键观察：每个 2×1 的小矩形可以有两种放置方式：
1. **竖着放**：占据 2×1 的空间
2. **横着放**：由于矩形高度为2，横着放需要两个矩形叠放，占据 2×2 的空间

### 状态转移分析

设 `f(n)` 表示覆盖 2×n 矩形的方法数。

对于 2×n 的矩形，考虑最右边的覆盖方式：

1. **最右边放一个竖着的矩形**：
   - 占据最右边的 2×1 空间
   - 剩余 2×(n-1) 的空间需要覆盖
   - 方法数为 `f(n-1)`

2. **最右边放两个横着的矩形**：
   - 两个矩形横着叠放，占据最右边的 2×2 空间
   - 剩余 2×(n-2) 的空间需要覆盖
   - 方法数为 `f(n-2)`

因此状态转移方程为：
```
f(n) = f(n-1) + f(n-2)  (n ≥ 2)
```

### 边界条件

- `f(0) = 0`：题目约定
- `f(1) = 1`：只有一种方法（一个竖着的矩形）


### 算法思路

这实际上就是**斐波那契数列**的变形：
- 初始值：`f(0) = 0, f(1) = 1`
- 但是从 `f(2)` 开始，遵循 `f(n) = f(n-1) + f(n-2)`
- 其中 `f(2) = 2`（这是通过实际分析得出的）

### 复杂度分析

- **时间复杂度**：O(n)，只需要一次循环
- **空间复杂度**：O(1)，只使用了常数个变量

### 核心思想

这道题的本质是：
1. **状态定义**：`f(n)` 表示覆盖 2×n 矩形的方法数
2. **状态转移**：考虑最后一列的放置方式，得到递推关系
3. **优化存储**：由于只依赖前两个状态，可以用滚动数组优化空间

这种"考虑最后一步的所有可能情况"是动态规划问题的经典思路，在很多类似的铺砖、爬楼梯问题中都会用到。

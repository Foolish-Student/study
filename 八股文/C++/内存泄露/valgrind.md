Valgrind 检查内存泄露的**原理**，核心是：它并不是依赖编译器插桩，而是通过 **二进制翻译 + 内存访问监控** 来实现的。具体可以分几个层面来理解：

---

## 1. 二进制指令级模拟（Dynamic Binary Instrumentation）

* Valgrind 在运行时会把程序的机器指令 **翻译成中间代码（IR，Intermediate Representation）**，再用自己的“虚拟 CPU”执行。
* 这样它就能 **完全掌控每一条内存读写、分配、释放操作**。
* 这也是为什么 Valgrind 程序会变慢 10\~50 倍：因为所有指令都在“虚拟机”里跑。

---

## 2. 内存分配跟踪

* Valgrind 会拦截 `malloc/free`、`new/delete`、`mmap/munmap` 等分配与释放函数。
* 它会在内部维护一张“内存分配表”，记录每一块内存的：

  * 分配时的调用堆栈；
  * 地址范围；
  * 是否已释放。

这样，在程序结束时 Valgrind 可以直接检查：

* 哪些内存分配了但没释放（潜在泄漏）；
* 哪些内存释放后又被使用（悬挂指针）；
* 哪些地址越界访问。

---

## 3. 内存状态监控（Shadow Memory）

* Valgrind 会维护一份 **影子内存（shadow memory）**，与真实进程内存一一对应。
* 每个字节的影子区会存储额外的状态信息，比如：

  * 该字节是否已分配；
  * 是否初始化；
  * 是否已释放。
* 当程序访问内存时，Valgrind 同步检查影子内存里的状态，判断是否合法。

---

## 4. 泄漏检测逻辑

* 程序退出时，Valgrind 遍历分配表：

  * 如果某块内存仍然“可达”（有指针指向，属于全局变量、栈变量链路上能找到），它不会算作泄漏（可能是故意保留）；
  * 如果某块内存已经不可达（找不到任何指针指向），就报告为 **definitely lost（确实丢失）**；
  * 如果内存可能通过某些指针访问但不确定，就标为 **possibly lost**。

---

## 5. 总结原理

Valgrind 之所以能查内存泄漏，是因为它：

1. **用虚拟 CPU 执行程序** → 捕获所有指令和系统调用；
2. **维护内存分配表** → 追踪每一次分配和释放；
3. **影子内存机制** → 标记每个字节的状态，检查非法访问；
4. **进程结束时分析** → 找出未释放或不可达的内存。

---

✅ 一句话总结：
**Valgrind 本质上是一个指令级模拟器，它通过二进制翻译拦截所有内存操作，利用分配表和影子内存记录状态，在程序退出时检测哪些内存未释放或非法使用，从而发现内存泄露。**


**`select` / `poll` / `epoll`**，它们是 Linux 下三种常见的 **I/O 多路复用机制**，主要用于 **高并发网络编程**（比如服务器同时处理成千上万个 socket 连接）。

下面我按顺序给你介绍一下：

---

## 1. select

* **机制**：
  内核通过遍历用户传进来的 **文件描述符集合**（fd\_set），检查哪些 fd 可读/可写/异常。
* **特点**：

  * 每次调用都要 **拷贝整个 fd 集合** 到内核，效率低；
  * 支持的 fd 数量有限（默认 1024，可通过修改宏 `FD_SETSIZE` 改大）；
  * 复杂度 **O(n)**，需要扫描所有 fd。
* **优点**：兼容性最好，历史最久，几乎所有系统都支持。
* **缺点**：效率低，不适合大规模并发。

---

## 2. poll

* **机制**：
  和 select 类似，但改进了数据结构。它使用 **pollfd 数组** 存放 fd，避免了 select 的 fd 集合限制。
* **特点**：

  * 没有最大 fd 数量限制；
  * 但是仍然需要 **线性遍历**，复杂度 **O(n)**；
  * 每次调用也需要把数组传给内核（虽然比 select 好一点）。
* **优点**：突破了 select 的 fd 数量限制，接口更灵活。
* **缺点**：在大量连接场景下仍然低效。

---

## 3. epoll（Linux 独有）

* **机制**：
  使用 **事件驱动（event-driven）** 的方式。内核维护一个事件表（红黑树 + 就绪链表），只返回 **活跃的 fd**，避免了 O(n) 遍历。
* **特点**：

  * 没有 fd 数量限制；
  * 只返回就绪的 fd，复杂度 **O(1)**；
  * 内核和用户态之间的交互开销小；
  * 支持 **边缘触发（edge-triggered, ET）** 和 **水平触发（level-triggered, LT）** 两种模式。
* **优点**：非常适合高并发场景（如百万连接服务器）。
* **缺点**：仅在 Linux 下可用，接口相对复杂。

---

## 4. 对比总结

| 特性           | select          | poll           | epoll               |
| ------------ | --------------- | -------------- | ------------------- |
| **时间复杂度**    | O(n)            | O(n)           | O(1)（只返回活跃的 fd）     |
| **最大 fd 数量** | 1024（可改，但有限制）   | 无限制            | 无限制                 |
| **是否拷贝数据**   | 每次调用都拷贝 fd\_set | 每次调用都拷贝 pollfd | 只需在 epoll\_ctl 时传一次 |
| **触发模式**     | 水平触发（LT）        | 水平触发（LT）       | 支持水平触发和边缘触发         |
| **平台支持**     | 跨平台（POSIX）      | 跨平台（POSIX）     | Linux 独有            |

---

✅ **一句话总结**：

* `select`：古老但兼容性最好，适合小规模。
* `poll`：改进版 select，支持更多连接，但效率仍然差。
* `epoll`：Linux 的高效解决方案，适合大规模并发服务器。

**`unordered_map`（底层是哈希表）的扩容机制**。
这个机制的核心就是 **当元素数量过多、负载因子超过阈值时，哈希表会进行 rehash（扩容+重排）**。

---

## 1. 负载因子（Load Factor）

* **定义**：

  $$
  \text{load factor} = \frac{\text{元素个数}}{\text{桶数}}
  $$
* C++ 标准库里，默认 **最大负载因子（max\_load\_factor）是 1.0**。
  也就是说，平均每个桶存一个元素时，允许继续插入；如果超过，就要扩容。

---

## 2. 触发扩容条件

当插入新元素后满足：

$$
\text{元素个数} > \text{桶数} \times \text{max\_load\_factor}
$$

就会触发 **rehash**。

---

## 3. 扩容的具体过程

1. **计算新桶数**

   * 一般会选择 **大于当前元素数 / max\_load\_factor 的最小质数** 作为新桶数。
   * 不同实现可能不同：GCC libstdc++ 和 MSVC STL 都采用 **质数表**来保证散列均匀。

2. **新建桶数组**
   分配新的桶空间，数量为新桶数。

3. **元素重新分布（rehash）**
   遍历所有元素，重新计算它们在新桶中的位置（因为桶数变了，`hash % new_bucket_count` 的结果也变了）。

4. **替换旧桶数组**
   释放旧桶数组，用新桶取而代之。

---

## 4. 扩容代价

* **一次 rehash 代价较大**：所有元素要重新 hash 并移动。
* **摊还复杂度**：由于扩容次数大约是对数级别（每次容量成倍增长），所以 **平均插入的复杂度仍然是 O(1)**。

---

## 5. 常用接口

* `unordered_map::rehash(n)`
  强制将桶数调整为 ≥ `n`。
* `unordered_map::reserve(n)`
  预留能容纳 `n` 个元素的桶，避免多次扩容。
  （推荐：如果大概知道要插入多少元素，可以先 `reserve` 提前扩容，减少 rehash 开销。）

---

## ✅ 总结

`unordered_map` 的扩容机制：

1. 使用 **哈希表 + 链式桶** 存储；
2. 当 **元素数 / 桶数 > max\_load\_factor** 时触发扩容；
3. 扩容时，**桶数增大到下一个质数**，并 **rehash** 所有元素；
4. 单次扩容代价高，但摊还下来 **插入是 O(1) 平均复杂度**。

# 暂停线程池
```cpp
/**
* @brief 暂停线程池。工作线程将临时停止从队列中检索新任务，尽管任何已经执行的任务将继续运行直到完成。仅在模板参数中启用`BS::tp::pause`标志时才启用。
*/
BS_THREAD_POOL_IF_PAUSE_ENABLED
void pause()
{
    const std::scoped_lock tasks_lock(tasks_mutex);
    paused = true;
}
```
```cpp
/**
* @brief 检查线程池是否当前被暂停。仅在模板参数中启用`BS::tp::pause`标志时才启用。
*
* @return 如果线程池被暂停，则返回`true`；如果没有被暂停，则返回`false`。
*/
BS_THREAD_POOL_IF_PAUSE_ENABLED
[[nodiscard]] bool is_paused() const
{
    const std::scoped_lock tasks_lock(tasks_mutex);
    return paused;
}
```
```cpp
/**
* @brief 取消暂停线程池。工作线程将恢复从队列中检索新任务。仅在模板参数中启用`BS::tp::pause`标志时才启用。
*/
BS_THREAD_POOL_IF_PAUSE_ENABLED
void unpause()
{
    {
        const std::scoped_lock tasks_lock(tasks_mutex);
        paused = false;
    }
    task_available_cv.notify_all();
}
```

# 实现原理
1. **编译期启用**：创建线程池时使用 `BS::tp::pause` 模板参数
2. **状态控制**：通过 `paused` 布尔变量控制暂停状态
3. **线程安全**：所有操作都使用 `tasks_mutex` 保护
4. **恢复通知**：`unpause()` 后用 `notify_all()` 唤醒所有等待的工作线程
5. **影响范围**：暂停后工作线程停止取新任务，但已执行的任务继续完成


# 注意事项
- 暂停只影响新任务的获取，正在执行的任务不会被中断
- 需要在模板参数中启用 `BS::tp::pause` 标志
- `wait()` 等函数在暂停状态下有特殊的等待逻辑
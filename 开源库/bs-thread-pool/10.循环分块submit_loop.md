# 循环分块
```cpp
 /**
* @brief 通过自动将循环分割成块并以指定优先级将每个块分别提交到队列来并行化循环。循环函数接受一个参数（循环索引），因此每个块会被调用多次。它必须没有返回值。返回一个包含所有块的future的`BS::multi_future`。
*
* @tparam T1 第一个索引的类型。应该是有符号或无符号整数。
* @tparam T2 最后一个索引之后的索引类型。应该是有符号或无符号整数。
* @tparam F 要循环的函数类型。
* @param first_index 循环中的第一个索引。
* @param index_after_last 循环中最后一个索引之后的索引。循环将从`first_index`到`(index_after_last - 1)`（包含）进行迭代。换句话说，它等价于`for (T i = first_index; i < index_after_last; ++i)`。请注意，如果`index_after_last <= first_index`，将不会提交任何任务，并将返回一个空的`BS::multi_future`。
* @param loop 要循环的函数。每个索引调用一次，每个块多次。应该恰好接受一个参数：循环索引。它不能有返回值。
* @param num_blocks 将循环分割成的最大块数。默认值为0，这意味着块数将等于池中的线程数。
* @param priority 任务的优先级。应该在-128到+127之间（有符号8位整数）。默认值为0。仅在模板参数中启用`BS::tp::priority`标志时才会考虑，否则无效果。
* @return 一个`BS::multi_future`，可用于等待所有块完成。
*/
template <typename T1, typename T2, typename T = common_index_type_t<T1, T2>, typename F>
[[nodiscard]] multi_future<void> submit_loop(const T1 first_index, const T2 index_after_last, F&& loop, const std::size_t num_blocks = 0, const priority_t priority = 0)
{
    if (static_cast<T>(index_after_last) > static_cast<T>(first_index))
    {
        const std::shared_ptr<std::decay_t<F>> loop_ptr = std::make_shared<std::decay_t<F>>(std::forward<F>(loop));
        const blocks blks(static_cast<T>(first_index), static_cast<T>(index_after_last), num_blocks ? num_blocks : thread_count);
        multi_future<void> future;
        future.reserve(blks.get_num_blocks());
        for (std::size_t blk = 0; blk < blks.get_num_blocks(); ++blk)
        {
            future.push_back(submit_task(
                [loop_ptr, start = blks.start(blk), end = blks.end(blk)]
                {
                    for (T i = start; i < end; ++i)
                        (*loop_ptr)(i);
                },
                priority));
        }
        return future;
    }
    return {};
}
```

# 与 `submit_blocks` 的区别

## 核心差异
- **submit_blocks**：块函数接受 `(start, end)` 参数，每个块只调用**一次**块函数
- **submit_loop**：循环函数接受单个索引参数，在每个块中**循环调用**函数

## 调用方式对比
```cpp
// submit_blocks 用法
submit_blocks(0, 1000, [](int start, int end) {
    for (int i = start; i < end; ++i) {
        process(i);  // 用户需要自己写循环
    }
});

// submit_loop 用法  
submit_loop(0, 1000, [](int i) {
    process(i);  // 函数自动为每个索引调用
});
```

## 实现原理
`submit_loop` 内部在每个分块中自动生成循环：
```cpp
for (T i = start; i < end; ++i)
    (*loop_ptr)(i);  // 为每个索引调用一次函数
```

## 使用场景
- **submit_blocks**：适合需要自定义分块处理逻辑的场景
- **submit_loop**：适合简单的逐元素并行处理，使用更便捷
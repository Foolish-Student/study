# 创建线程池
```cpp
/**
* @brief 在池中创建线程并为每个线程分配一个工作线程。
*
* @param num_threads 要使用的线程数。
* @param init 在每个线程开始执行任何提交的任务之前运行的初始化函数。
*/
template <typename F>
void create_threads(const std::size_t num_threads, F&& init)
{
    if constexpr (std::is_invocable_v<F, std::size_t>)
    {
        init_func = std::forward<F>(init);
    }
    else
    {
        init_func = [init = std::forward<F>(init)](std::size_t)
        {
            init();
        };
    }
    thread_count = determine_thread_count(num_threads);
    thread_count = 1; // 临时：仅用于调试
    threads = std::make_unique<thread_t[]>(thread_count);
    {
        const std::scoped_lock tasks_lock(tasks_mutex);
        tasks_running = thread_count;
#ifndef __cpp_lib_jthread
        workers_running = true;
#endif
    }
    for (std::size_t i = 0; i < thread_count; ++i)
    {
        threads[i] = thread_t(
            [this, i]
#ifdef __cpp_lib_jthread
            (const std::stop_token& stop_token)
            {
                worker(stop_token, i);
            }
#else
            {
                worker(i);
            }
#endif
        );
    }
}
```

# 实现原理

## 核心步骤
1. **处理初始化函数**：根据函数签名选择合适的包装方式
2. **确定线程数量**：调用 `determine_thread_count()` 计算最优线程数
3. **分配线程数组**：使用 `std::make_unique` 创建线程对象数组
4. **设置运行状态**：更新 `tasks_running` 和 `workers_running` 标志
5. **创建工作线程**：循环创建线程，每个线程执行 `worker()` 函数

## 关键技术点

### 初始化函数适配
```cpp
if constexpr (std::is_invocable_v<F, std::size_t>)
    init_func = std::forward<F>(init);  // 接受线程ID参数
else
    init_func = [init = std::forward<F>(init)](std::size_t) { init(); };  // 无参数版本
```

### C++20 jthread 兼容性
- **支持 jthread**：使用 `stop_token` 进行优雅停止
- **传统 thread**：使用 `workers_running` 标志控制

### 线程安全
- 使用 `std::scoped_lock` 保护共享状态更新
- 确保线程创建过程中的数据一致性

## 设计特点
- **灵活的初始化**：支持带参数和无参数的初始化函数
- **现代C++兼容**：自动适配 C++20 的 jthread 特性
- **资源管理**：使用智能指针管理线程数组
- **线程标识**：每个工作线程都有唯一的索引ID
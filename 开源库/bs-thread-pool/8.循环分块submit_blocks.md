# 循环分块submit_blocks
```cpp
/**
* @brief 通过自动将循环分割成块并以指定优先级将每个块分别提交到队列来并行化循环。块函数接受两个参数，块的开始和结束，因此每个块只被调用一次，但用户需要确保块函数正确处理每个块中的所有索引。返回一个包含所有块的future的`BS::multi_future`。
*
* @tparam T1 第一个索引的类型。应该是有符号或无符号整数。
* @tparam T2 最后一个索引之后的索引类型。应该是有符号或无符号整数。
* @tparam F 要循环的函数类型。
* @tparam R 要循环的函数的返回类型（可以是`void`）。
* @param first_index 循环中的第一个索引。
* @param index_after_last 循环中最后一个索引之后的索引。循环将从`first_index`到`(index_after_last - 1)`（包含）进行迭代。换句话说，它等价于`for (T i = first_index; i < index_after_last; ++i)`。请注意，如果`index_after_last <= first_index`，将不会提交任何块，并将返回一个空的`BS::multi_future`。
* @param block 每个块调用一次的函数。应该恰好接受两个参数：块中的第一个索引和块中最后一个索引之后的索引。`block(start, end)`通常应该包含形式为`for (T i = start; i < end; ++i)`的循环。
* @param num_blocks 将循环分割成的最大块数。默认值为0，这意味着块数将等于池中的线程数。
* @param priority 任务的优先级。应该在-128到+127之间（有符号8位整数）。默认值为0。仅在模板参数中启用`BS::tp::priority`标志时才会考虑，否则无效果。
* @return 一个`BS::multi_future`，可用于等待所有块完成。如果块函数返回一个值，`BS::multi_future`也可以用于获取每个块返回的值。
*/
template <typename T1, typename T2, typename T = common_index_type_t<T1, T2>, typename F, typename R = std::invoke_result_t<std::decay_t<F>, T, T>>
[[nodiscard]] multi_future<R> submit_blocks(const T1 first_index, const T2 index_after_last, F&& block, const std::size_t num_blocks = 0, const priority_t priority = 0)
{
    if (static_cast<T>(index_after_last) > static_cast<T>(first_index))
    {
        const std::shared_ptr<std::decay_t<F>> block_ptr = std::make_shared<std::decay_t<F>>(std::forward<F>(block));
        const blocks blks(static_cast<T>(first_index), static_cast<T>(index_after_last), num_blocks ? num_blocks : thread_count);
        multi_future<R> future;
        future.reserve(blks.get_num_blocks());
        for (std::size_t blk = 0; blk < blks.get_num_blocks(); ++blk)
        {
            future.push_back(submit_task(
                [block_ptr, start = blks.start(blk), end = blks.end(blk)]
                {
                    return (*block_ptr)(start, end);
                },
                priority));
        }
        return future;
    }
    return {};
}
```

# 实现思路

## 核心功能
`submit_blocks` 函数用于将一个大的循环任务自动分割成多个小块，并行执行以提高性能。

## 实现步骤
1. **参数验证**：检查索引范围是否有效 (`index_after_last > first_index`)
2. **函数对象封装**：使用 `shared_ptr` 封装传入的块函数，确保在多线程环境下安全共享
3. **任务分块**：实例化 `blocks` 辅助类，根据索引范围和线程数自动计算分块策略
4. **创建 multi_future**：构造返回值容器，预分配空间以提高性能
5. **提交子任务**：遍历每个分块，使用 lambda 表达式封装子任务并提交到线程池
6. **返回结果**：返回包含所有子任务 future 的 `multi_future` 对象

## 关键技术点
- **完美转发**：使用 `std::forward<F>(block)` 保持函数对象的值类别
- **类型推导**：自动推导公共索引类型和返回值类型
- **内存优化**：预分配 future 容器空间，避免动态扩容
- **异常安全**：如果索引范围无效，返回空的 `multi_future`

## 使用场景
适用于可以并行化的循环操作，如：
- 数组/向量的批量处理
- 数值计算的分块并行
- 大数据集的并行遍历
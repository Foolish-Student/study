# C++17高级语法解释
## 1. `std::conditional_t<条件, 类型A, 类型B>`
```cpp
std::conditional_t<priority_enabled, std::priority_queue<pr_task>, std::queue<task_t>> tasks;
```
这是C++中的模板元编程语法，std::conditional_t 是一个类型选择工具。

解释：


std::conditional_t<条件, 类型A, 类型B>
如果条件为 true，则类型是 类型A；否则是 类型B。
在你的代码里：


priority_enabled 是一个 constexpr bool，表示是否启用优先级。
如果启用优先级，tasks 就是 std::priority_queue<pr_task>（优先队列）。
如果没启用优先级，tasks 就是 std::queue<task_t>（普通队列）。
作用：
根据编译期的选项，自动选择不同的任务队列类型。这样可以让同一个类支持不同的功能，而不用写重复代码。


## 2. `std::scoped_lock`

`std::scoped_lock` 是 C++17 引入的智能锁，主要区别：

1. **多锁支持**：可以同时锁定多个互斥量，`std::lock_guard` 只能锁一个
   ```cpp
   std::scoped_lock lock(mtx1, mtx2, mtx3);  // 同时锁多个
   ```

2. **自动避免死锁**：内部使用 `std::lock` 算法，安全获取多个锁

3. **性能更好**：比 `std::unique_lock` 开销小，专为简单场景优化

4. **使用简洁**：支持类模板参数推导，不需要写模板参数

**选择建议**：
- 单锁 → `std::lock_guard`
- 多锁 → `std::scoped_lock` 
- 需要灵活控制 → `std::unique_lock`

## 3. `std::decay_t<F>`
`std::decay_t<F>` 是 C++14 引入的类型转换工具，用于"衰减"类型。

什么是类型衰减（decay）
类型衰减是指将类型转换为其"最基本"的形式，去除各种修饰符：
* 去除引用：int& → int，int&& → int
* 去除cv限定符：const int → int，volatile int → int
* 数组转指针：int[10] → int*
* 函数转函数指针：void() → void(*)()

## 4. `std::invoke_result_t<Callable, Args...>`
* Callable：可调用对象的类型
* Args...：调用参数的类型（可选）

作用：
* 自动推导返回值类型：不需要手动指定任务函数的
返回值类型
* 支持各种可调用对象：函数、lambda、函数对象等
* 类型安全：确保 std::future<R> 中的 R 类型正确

## 5. `[[nodiscard]]`
是 C++17 引入的属性（attribute），用于提醒编译器和开发者不要忽略函数的返回值。

基本作用
当函数被标记为 `[[nodiscard]]` 时，如果调用者忽略了返回值，编译器会发出警告。

好处
* 代码质量：减少因忽略重要返回值导致的bug
* 文档作用：明确表示这个返回值很重要
* 维护性：帮助代码审查时发现潜在问题

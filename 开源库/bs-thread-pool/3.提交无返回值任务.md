# 提交无返回值任务
## 任务队列
`thread_pool` 拥有一个私有的任务队列
```cpp
/**
* @brief 由线程执行的任务队列。
*/
std::conditional_t<priority_enabled, std::priority_queue<pr_task>, std::queue<task_t>> tasks;
```
`priority_enabled` 是一个 `constexpr bool`，表示是否启用优先级
如果启用优先级，`tasks` 就是 `std::priority_queue<pr_task>`（优先队列）
如果没启用优先级，`tasks` 就是 `std::queue<task_t>`（普通队列）

## 添加任务
```cpp
 /**
* @brief 将一个无参数和无返回值的函数以指定优先级提交到任务队列。要提交带参数的函数，请将其封装在lambda表达式中。不返回future，因此用户必须使用`wait()`或其他方法来确保任务完成执行，否则会发生不好的事情。
*
* @tparam F 函数的类型。
* @param task 要提交的函数。
* @param priority 任务的优先级。应该在-128到+127之间（有符号8位整数）。默认值为0。仅在模板参数中启用`BS::tp::priority`标志时才会考虑，否则无效果。
*/
template <typename F>
void detach_task(F&& task, const priority_t priority = 0)
{
    {
        const std::scoped_lock tasks_lock(tasks_mutex);
        if constexpr (priority_enabled)
            tasks.emplace(std::forward<F>(task), priority);
        else
            tasks.emplace(std::forward<F>(task));
    }
    task_available_cv.notify_one();
}
```

调用`submit_task`后，会调用`detach_task`函数，将任务添加到任务队列中


## 通知worker处理任务
条件变量
```cpp
/**
 * @brief 用于通知`worker()`有新任务可用的条件变量。
 */
std::condition_variable     task_available_cv;
```

任务添加完后会使用条件变量通知worker开始获取任务工作

## 线程安全机制
- `tasks_mutex`: 保护任务队列的并发访问
- `scoped_lock`: RAII方式自动管理锁的生命周期  
- `task_available_cv`: 条件变量实现线程间同步

## 完整的任务创建流程
1. 用户调用 `submit_task()` -> `detach_task()`
2. 获取 `tasks_mutex` 锁保护任务队列
3. 根据是否启用优先级，将任务添加到相应队列
4. 释放锁
5. 通过 `task_available_cv.notify_one()` 唤醒一个等待的工作线程

# 线程池销毁线程退出

## 函数实现
```cpp
/**
* @brief 销毁池中的线程。
*/
void destroy_threads()
{
    {
        const std::scoped_lock tasks_lock(tasks_mutex);
        workers_running = false;
    }
    task_available_cv.notify_all();
    for (std::size_t i = 0; i < thread_count; ++i)
        threads[i].join();
}
```

## 实现原理

### 1. 获取任务队列锁并设置停止标志
```cpp
{
    const std::scoped_lock tasks_lock(tasks_mutex);
    workers_running = false;
}
```
- 使用 `scoped_lock` 自动管理锁的生命周期
- 设置 `workers_running = false` 通知所有工作线程停止工作
- 使用作用域限制锁的持有时间，避免死锁

### 2. 唤醒所有等待的工作线程
```cpp
task_available_cv.notify_all();
```
- 通过条件变量唤醒所有在 `task_available_cv` 上等待的线程
- 让等待任务的线程检查 `workers_running` 状态并退出

### 3. 等待所有线程完成
```cpp
for (std::size_t i = 0; i < thread_count; ++i)
    threads[i].join();
```
- 逐个调用 `join()` 等待每个工作线程完成
- 确保所有线程都已经退出后，主线程才继续执行

## 关键设计点

### 线程安全的停止机制
- **原子操作**：`workers_running` 标志的修改在锁保护下进行
- **条件变量**：使用 `notify_all()` 确保所有等待线程都能收到停止信号
- **优雅退出**：通过 `join()` 等待线程自然退出，避免强制终止

### 避免死锁的设计
- **作用域锁**：使用 `scoped_lock` 确保锁在设置标志后立即释放
- **先通知后等待**：先唤醒所有线程，再等待它们退出


## 使用场景
- 线程池析构函数中调用，确保资源正确释放
- 程序退出前的清理工作
- 动态调整线程池大小时的线程回收

## 注意事项
- 必须在线程池不再接收新任务后调用
- 调用后线程池将无法继续工作，需要重新初始化
- 确保所有提交的任务都已处理完毕或可以安全丢弃
# 顺序执行索引任务
```cpp
/**
* @brief 将由索引枚举的任务序列以指定优先级提交到队列。序列函数接受一个参数（任务索引），并将每个索引调用一次。返回一个包含所有任务future的`BS::multi_future`。
*
* @tparam T1 第一个索引的类型。应该是有符号或无符号整数。
* @tparam T2 最后一个索引之后的索引类型。应该是有符号或无符号整数。
* @tparam F 用于定义序列的函数类型。
* @tparam R 用于定义序列的函数的返回类型（可以是`void`）。
* @param first_index 序列中的第一个索引。
* @param index_after_last 序列中最后一个索引之后的索引。序列将从`first_index`到`(index_after_last - 1)`（包含）进行迭代。换句话说，它等价于`for (T i = first_index; i < index_after_last; ++i)`。请注意，如果`index_after_last <= first_index`，将不会提交任何任务，并将返回一个空的`BS::multi_future`。
* @param sequence 用于定义序列的函数。每个索引调用一次。应该恰好接受一个参数，即索引。
* @param priority 任务的优先级。应该在-128到+127之间（有符号8位整数）。默认值为0。仅在模板参数中启用`BS::tp::priority`标志时才会考虑，否则无效果。
* @return 一个`BS::multi_future`，可用于等待所有任务完成。如果序列函数返回一个值，`BS::multi_future`也可以用于获取每个任务返回的值。
*/
template <typename T1, typename T2, typename T = common_index_type_t<T1, T2>, typename F, typename R = std::invoke_result_t<std::decay_t<F>, T>>
[[nodiscard]] multi_future<R> submit_sequence(const T1 first_index, const T2 index_after_last, F&& sequence, const priority_t priority = 0)
{
    if (static_cast<T>(index_after_last) > static_cast<T>(first_index))
    {
        const std::shared_ptr<std::decay_t<F>> sequence_ptr = std::make_shared<std::decay_t<F>>(std::forward<F>(sequence));
        multi_future<R> future;
        future.reserve(static_cast<std::size_t>(static_cast<T>(index_after_last) > static_cast<T>(first_index)));
        for (T i = static_cast<T>(first_index); i < static_cast<T>(index_after_last); ++i)
        {
            future.push_back(submit_task(
                [sequence_ptr, i]
                {
                    return (*sequence_ptr)(i);
                },
                priority));
        }
        return future;
    }
    return {};
}
```


# 核心功能
`submit_sequence` 将一系列索引任务提交到线程池，每个索引对应一个独立的任务。

# 实现原理
1. **索引范围验证**：检查 `index_after_last > first_index`
2. **函数对象封装**：使用 `shared_ptr` 封装序列函数，确保多线程安全
3. **预分配容器**：为 `multi_future` 预留空间
4. **逐个提交任务**：循环遍历每个索引，为每个索引创建独立任务
5. **返回结果集合**：返回包含所有任务 future 的 `multi_future`

# 与其他函数的区别

## 与 `submit_loop` 的区别
- **submit_sequence**：每个索引是**独立的任务**，可以并行执行
- **submit_loop**：索引在**分块内顺序执行**，分块间并行

## 与 `submit_blocks` 的区别  
- **submit_sequence**：函数接受**单个索引**参数，每个索引一个任务
- **submit_blocks**：函数接受**索引范围**参数，每个块一个任务

# 使用场景
```cpp
// 示例：处理数组中的每个元素，每个元素独立处理
submit_sequence(0, 1000, [&](int i) {
    return process_element(data[i]);  // 每个索引独立处理
});
```

# 特点
- **最大并行度**：每个索引都是独立任务，理论上可以完全并行
- **内存开销**：会创建大量任务对象，适合索引数量不太大的场景
- **灵活性**：每个任务可以有不同的返回值和执行时间
# 规定时间内任务是否都完成

## 📌 功能概述
`wait_for` 函数用于在指定时间内等待线程池中的所有任务完成，是一个**带超时的同步等待**机制。

## 🔍 函数实现
```cpp
template <typename R, typename P>
bool wait_for(const std::chrono::duration<R, P>& duration)
{
#ifdef __cpp_exceptions
    if constexpr (wait_deadlock_checks_enabled)
    {
        if (this_thread::get_pool() == this)
            throw wait_deadlock();
    }
#endif
    std::unique_lock tasks_lock(tasks_mutex);
    waiting = true;
    const bool status = tasks_done_cv.wait_for(tasks_lock, duration,
        [this]
        {
            if constexpr (pause_enabled)
                return (tasks_running == 0) && (paused || tasks.empty());
            else
                return (tasks_running == 0) && tasks.empty();
        });
    waiting = false;
    return status;
}
```

## 📋 逐步解析

### 1. **死锁检测**（第6-11行）
```cpp
if (this_thread::get_pool() == this)
    throw wait_deadlock();
```
- **目的**：防止线程池内的工作线程调用 `wait_for` 等待自己
- **原因**：工作线程等待任务完成，但它自己就是执行任务的线程 → 死锁

### 2. **获取锁并设置状态**（第13-14行）
```cpp
std::unique_lock tasks_lock(tasks_mutex);
waiting = true;
```
- **互斥锁**：保护共享资源的线程安全访问
- **等待标志**：标记当前有线程在等待任务完成

### 3. **条件等待**（第15-22行）
```cpp
const bool status = tasks_done_cv.wait_for(tasks_lock, duration, [this] {
    if constexpr (pause_enabled)
        return (tasks_running == 0) && (paused || tasks.empty());
    else
        return (tasks_running == 0) && tasks.empty();
});
```

**等待条件**：
- **基本条件**：`tasks_running == 0`（没有任务在执行）
- **完成条件**：
  - 支持暂停：`paused || tasks.empty()`（暂停状态 或 队列为空）
  - 不支持暂停：`tasks.empty()`（队列为空）

### 4. **清理并返回**（第23-24行）
```cpp
waiting = false;
return status;
```

## 🎯 返回值含义
- **`true`**：在规定时间内，所有任务都完成了
- **`false`**：超时了，仍有任务未完成

## 💡 使用场景
```cpp
// 等待最多 5 秒让所有任务完成
if (pool.wait_for(std::chrono::seconds(5))) {
    std::cout << "所有任务已完成" << std::endl;
} else {
    std::cout << "超时：仍有任务未完成" << std::endl;
}
```
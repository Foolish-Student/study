# 分块算法
## start
```cpp
/**
    * @brief 获取块的第一个索引。
    *
    * @param block 块编号。
    * @return 第一个索引。
    */
[[nodiscard]] T start(const std::size_t block) const noexcept
{
    return first_index + static_cast<T>(block * block_size) + static_cast<T>(block < remainder ? block : remainder);
}
```
这是**区间均匀分块算法**，常用于并行计算任务分配。它的核心思想是：把一个区间（如数组、循环迭代）分成尽量均匀的若干块，每块分配给一个线程或任务。

具体做法如下：

1. 先计算每块的基础大小（整除部分）。
2. 如果不能整除，会有一些“余数”任务，把这些余数均匀分配到前面的若干块，每块多分一个。
3. 这样可以保证所有块的任务数量相差不超过1，实现负载均衡。

这种算法在多线程并行处理时非常常见，比如OpenMP、TBB等库也会用类似的分块策略。它的“神奇”之处在于简单高效，且能保证分配均匀，避免某些线程任务过多或过少导致性能瓶颈。


- `first_index = 0`
- `index_after_last = 10`
- `num_blocks = 3`

计算过程如下：

1. **总任务数**  
   `total = index_after_last - first_index = 10 - 0 = 10`

2. **每块基础大小**  
   `block_size = total / num_blocks = 10 / 3 = 3`（整除，取整数部分）

3. **余数**  
   `remainder = total % num_blocks = 10 % 3 = 1`

4. **每块的起止索引**  
   对于每个块 `block`（0, 1, 2）：

   - `start = first_index + block * block_size + (block < remainder ? block : remainder)`
   - `end = first_index + (block + 1) * block_size + ((block + 1) < remainder ? (block + 1) : remainder)`

   具体计算：

   - **block 0**  
     `start = 0 + 0*3 + (0<1?0:1) = 0 + 0 + 0 = 0`  
     `end = 0 + 1*3 + (1<1?1:1) = 0 + 3 + 1 = 4`

   - **block 1**  
     `start = 0 + 1*3 + (1<1?1:1) = 0 + 3 + 1 = 4`  
     `end = 0 + 2*3 + (2<1?2:1) = 0 + 6 + 1 = 7`

   - **block 2**  
     `start = 0 + 2*3 + (2<1?2:1) = 0 + 6 + 1 = 7`  
     `end = 0 + 3*3 + (3<1?3:1) = 0 + 9 + 1 = 10`

所以分块结果是：

- block 0: [0, 4)
- block 1: [4, 7)
- block 2: [7, 10)

这样每块的任务分配就很清楚了。
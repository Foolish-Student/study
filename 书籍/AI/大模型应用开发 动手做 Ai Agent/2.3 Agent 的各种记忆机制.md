# 2.3 Agent 的各种记忆机制（重点梳理）

## 1️⃣ 为什么 Agent 一定要有“记忆”？

先抓大方向：

* 只靠大模型的**上下文窗口**，Agent 只能“短时记住这几千 token”，任务一长就“失忆”。
* 真正实用的 Agent，要能：

  * 记住用户：偏好、历史对话、习惯；
  * 记住任务：之前做过什么、做到哪一步了；
  * 记住知识：长期可复用的信息（文档、FAQ、经验）。

**记忆机制的核心目的：**

> 让 Agent 从“一次性对话机器人”变成“长期陪跑、能持续成长的智能体”。

---

## 2️⃣ 几类关键记忆（按“用来干嘛”来分）

可以这样记 3 大类（名字不一定和书里一模一样，但功能是一致的）：

### （1）对话 / 短期记忆：保持上下文连贯

* 内容：当前对话轮次、最近的工具调用结果、当前任务的中间状态等。
* 实现：直接放在 Prompt 里，或用“最近 N 轮对话 + 关键摘要”形式。
* 作用：

  * 让 Agent **别一句话就忘前文**；
  * 能正确引用前面用户说过的话和中间结果。

> 对应你能感受到的：聊着聊着，Agent 还记得你刚才提到的参数、目标、限制条件。

---

### （2）长期记忆：越用越懂你 & 越用越熟业务

* 内容：

  * 用户层面：个人偏好、常用风格、经常提到的项目/同事/课程等；
  * 知识层面：公司文档、FAQ、手册、历史案例、知识库；
  * 任务层面：之前做过的大项目的总结、复盘经验。
* 实现：

  * 存在外部数据库 / 向量库，用“相似度检索 + RAG”按需取回；
  * 或用结构化存储（表、KV、知识图谱）管理重要信息。
* 作用：

  * 让 Agent 在**不同会话之间保持连续性**；
  * 支持“问公司知识 / 项目历史 / 自己的旧任务”，像在和一个长期共事的助理合作。

---

### （3）任务 / 工具交互记忆：干活过程中的“操作日志”

* 内容：

  * 这个任务里已经调用过哪些工具、参数是什么、结果如何；
  * 哪些方案尝试过、哪些失败了、为什么放弃。
* 实现：

  * 作为一个“任务级记忆块”存下来，必要时做摘要；
  * 结合 ReAct / 自我反思框架，把“踩坑经验”沉淀进去。
* 作用：

  * 避免 Agent 重复犯同样的错，减少“原地打转”；
  * 方便后续复盘和解释：“这个结果是怎么一步步算出来的”。

---

## 3️⃣ 技术角度：记忆一般怎么做？

可以记成三个层次：

1. **直接塞进上下文（短期）**

   * 最近对话 / 最近工具结果 → 直接拼到 Prompt 里。
2. **向量检索（长期）**

   * 把文档 / 对话摘要 / 用户信息编码成向量 → 存入向量库；
   * 每次根据当前问题做检索 → 拿回最相关的几条 → 拼进 Prompt。
3. **结构化存储（任务与状态）**

   * 用表/KV/JSON/日志文件等存“任务进度、子任务列表、执行状态”；
   * Agent 通过工具接口读写这些状态，从而“记住自己做到哪一步了”。

---

## 4️⃣ 设计记忆机制时要想清楚的几个点

书的精神可以提炼成这几个问题：

1. **记什么，不记什么？**

   * 不是越多越好：要过滤无用细节，避免“信息垃圾堆积”。
   * 同时要考虑隐私与安全，不能乱记敏感数据。

2. **怎么高效地“找回来”？**

   * 检索策略要好（相似度、关键词、时间），
   * 否则记了一大堆但每次取回来的都不相关，也没意义。

3. **怎么处理过期 / 冲突信息？**

   * 旧版本文档 vs 新版本文档；
   * 用户偏好改变后，旧的记忆要不要降权或淘汰。

4. **成本问题：算力 + 存储 + Token**

   * 记忆越多，检索越重，Prompt 越长，成本就越高；
   * 需要做摘要、分层存储（热记忆 vs 冷记忆）来平衡。

---

你可以这样一句话记住 2.3：

> **记忆 = 让 Agent 拥有“连续性”和“成长性”的关键基础设施，
> 不只是“把上下文拉得很长”，而是要有选择地记录、检索和利用过去的信息。**

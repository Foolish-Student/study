# 第9条：慎重选择删除元素的方法

## 🎯 核心观点

STL 容器的**删除元素方法有多种**（`erase`、`remove`、`clear`、`pop_*` 等），但它们的语义和效率差别很大。
**错误选择可能导致：效率低下、逻辑错误或内存泄漏。**
因此，必须**根据容器类型和需求慎重选择删除方式**。

---

## ✅ 常见正确用法

### 1. 顺序容器（vector / deque / string）

```cpp
std::vector<int> v = {1, 2, 3, 2, 4};

// 删除所有等于 2 的元素
v.erase(std::remove(v.begin(), v.end(), 2), v.end());
```

解释：

* `remove` 只是“移到末尾”，不真正删除元素；
* 必须搭配 `erase` 才能真正缩短容器。
  👉 这被称为 **“erase-remove 惯用法”**。

---

### 2. 关联容器（set / map / multiset / multimap）

```cpp
std::set<int> s = {1, 2, 3, 2, 4};

// 删除所有等于 2 的元素（高效）
s.erase(2);
```

解释：

* 关联容器提供 **按值直接删除** 的 `erase(key)`，O(logN)，非常高效；
* 不要用 `remove`（不适用关联容器）。

---

### 3. 删除单个迭代器元素

```cpp
auto it = v.begin();
v.erase(it);  // 删除 it 指向的元素，并返回下一个迭代器
```

注意：删除后原迭代器失效，必须用返回值更新。

---

### 4. 清空容器

```cpp
v.clear();   // O(N)，调用析构，释放所有资源
```

---

## ❌ 不推荐写法（踩坑示例）

```cpp
std::vector<int> v = {1, 2, 3, 2, 4};

// ❌ 只调用 remove，不调用 erase
std::remove(v.begin(), v.end(), 2);

// v.size() 仍然是 5，最后的元素只是“未定义垃圾”
```

问题：

* `remove` 并不会缩容；`v.size()` 不变；逻辑错误隐蔽。

---

## 🛠 为什么要慎重？

1. **效率问题**

   * 顺序容器用 `erase-remove`，否则 O(N) 移动成本被浪费。
   * 关联容器应直接用 `erase(key)`，不要遍历 + erase。

2. **语义差异**

   * `remove` ≠ 删除，只是重新排列；必须配合 `erase`。
   * `pop_back` / `pop_front` 只能删一个，不能删多个。

3. **迭代器失效**

   * `vector/deque/string`：`erase` 可能使后续迭代器失效。
   * `list`：`erase` 只影响当前迭代器，其他迭代器仍然有效。
   * 关联容器：`erase(it)` 只使 `it` 本身失效。

---

## 📦 常见场景与正确用法

| 需求            | 推荐用法 ✅                      | 说明                |
| ------------- | --------------------------- | ----------------- |
| 删除某值（vector）  | `erase(remove(...), end())` | erase-remove 惯用法  |
| 删除某值（set/map） | `erase(key)`                | 内部自动查找并删除，O(logN) |
| 删除单个元素        | `erase(it)`                 | 注意更新迭代器           |
| 清空容器          | `clear()`                   | 释放所有资源            |
| 批量条件删除（list）  | `list.remove_if(pred)`      | 专有接口，避免手写循环       |

---

## ✅ 实用建议

* **顺序容器**：习惯性用 **erase-remove** 模式删除指定值。
* **关联容器**：优先用 `erase(key)`，不要遍历再删。
* **list**：利用 `remove_if`，更简洁高效。
* 删除迭代器元素时，**一定更新迭代器**，避免失效。
* 对资源对象，删除会调用析构，保证 RAII。

---

## 📌 小结

删除元素时要**选对方法**：

* **顺序容器** → `erase-remove 惯用法`
* **关联容器** → `erase(key)`
* **链表** → `remove_if`
* **别忘迭代器失效问题**

**删除不是一件简单事，方法选错，代价惨重！** 🚀

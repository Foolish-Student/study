# 第3条：确保容器中的对象拷贝正确而高效

## 🎯 核心观点

STL 容器在执行插入、删除、排序等操作时，**大量依赖对象的拷贝构造和赋值操作**。如果你的类型没有正确实现这些操作，可能导致：

* **程序错误**（浅拷贝引发悬垂指针、重复释放等问题）；
* **性能瓶颈**（不必要的深拷贝或资源分配）。

---

## 📦 STL 容器操作中何时发生拷贝？

| 操作                     | 是否拷贝对象      |
| ---------------------- | ----------- |
| `push_back` / `insert` | 是，拷贝或移动对象   |
| `resize`               | 是，默认构造 + 拷贝 |
| `sort`                 | 是，交换需要拷贝或移动 |
| `erase`                | 有时伴随元素移动    |

---

## ⚠️ 拷贝不当带来的问题

### ❌ 错误示例：浅拷贝导致悬垂指针

```cpp
class Bad {
public:
    Bad() { data = new int[100]; }
    ~Bad() { delete[] data; }
    Bad(const Bad& other) { data = other.data; }  // 浅拷贝：危险！
private:
    int* data;
};

std::vector<Bad> v;
v.push_back(Bad());  // 多次 push_back 会 double free！
```

### ✅ 正确示例：深拷贝或使用智能指针

```cpp
class Good {
public:
    Good() { data = std::make_shared<std::vector<int>>(100); }
private:
    std::shared_ptr<std::vector<int>> data;
};
```

---

## 🚀 高效性：避免不必要的拷贝

### 使用 `emplace` 替代 `insert` / `push_back`

```cpp
std::vector<MyClass> v;
v.emplace_back(arg1, arg2);  // 直接构造，无需额外拷贝
```

### 使用移动语义（C++11 及以上）

```cpp
MyClass(MyClass&& other);          // 移动构造
MyClass& operator=(MyClass&& rhs); // 移动赋值
```

若对象支持移动操作，STL 优先使用移动而非拷贝，提高性能。

---

## ✅ 建议总结

* **总是实现自己的拷贝构造函数和赋值操作符**（遵循 Rule of Three / Five / Zero）；
* **如果不需要拷贝，禁止拷贝（如删除构造函数）**；
* **为性能敏感的对象实现移动语义**；
* **插入容器时优先使用 `emplace` 和 `std::move`**；
* 使用 STL 容器时，**你的类型必须是值语义（Value Semantics）良好市民**。

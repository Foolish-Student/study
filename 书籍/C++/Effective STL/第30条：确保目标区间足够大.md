# **第30条：确保目标区间足够大**

## **核心思想**

在使用 STL 算法时，许多算法需要一个 **目标区间**（destination range），例如：

* `std::copy`：从源区间复制到目标区间
* `std::transform`：将操作结果写入目标区间
* `std::replace_copy`、`std::remove_copy` 等

**问题**：

* 如果目标区间不够大，会 **越界写入**，导致未定义行为。
* STL 算法本身不会检查目标区间大小，安全由程序员保证。

---

## **解决方法**

### 1️⃣ 确定目标区间大小

* **目标区间必须至少和源区间一样大**，否则可能写入越界。

示例：

```cpp
std::vector<int> src = {1,2,3,4};
std::vector<int> dest(4); // 必须分配足够空间
std::copy(src.begin(), src.end(), dest.begin());
```

* 如果写成：

```cpp
std::vector<int> dest(2); // 不够大
std::copy(src.begin(), src.end(), dest.begin()); // ❌ UB
```

---

### 2️⃣ 使用 `back_inserter` 或 `inserter` 自动扩容

* 当目标容器支持 `push_back` 或插入操作时，可以使用迭代器适配器：

```cpp
std::vector<int> dest;
std::copy(src.begin(), src.end(), std::back_inserter(dest)); // 自动扩容
```

* 优点：不用提前分配目标区间大小，避免越界

---

### 3️⃣ 总结规律

| 场景       | 方法                              | 注意点              |
| -------- | ------------------------------- | ---------------- |
| 目标区间固定大小 | 直接使用容器迭代器                       | 必须保证容器空间 ≥ 源区间长度 |
| 目标区间可变   | 使用 `back_inserter` / `inserter` | 自动扩容，安全且方便       |
| 算法返回迭代器  | 注意返回值指向的元素位置                    | 避免越界操作           |

---

## **常见错误**

1. **目标数组或容器空间不足** → 写入越界
2. **使用原生数组时忘记计算长度** → 越界、未定义行为
3. **误以为算法会自动扩容** → STL 容器不会自动扩容，除非使用 `back_inserter`

---

### ✅ **核心总结**

* **“源区间多大，目标区间至少要一样大”**
* 如果不确定目标区间大小，使用 **插入迭代器（`back_inserter` / `inserter`）**
* STL 算法本身 **不检查越界**，安全由程序员保证

---

💡 **一句口诀**：

> **“拷贝要有容器，空间不够用插入。”**

* 拷贝/转换操作 → 确保目标空间足够
* 不够 → 用 `back_inserter` 自动扩容

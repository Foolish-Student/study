# 第11条：理解自定义分配子的合理用法

## 🎯 核心观点

* **STL 容器允许自定义 allocator（分配子）**，用来控制内存的来源。
* 自定义分配子确实有用，但**使用场景有限**：

  * 要么放到 **特殊内存区域**（共享内存、内存映射文件、自建堆）；
  * 要么做 **统计/调试**（记录分配次数、检查越界）。
* 绝大多数情况下，默认的 `std::allocator` 就足够，**不要滥用**。

---

## ✅ 合理用法

1. **改变内存来源**

   * 比如把容器数据放到 **共享内存**，让多个进程共享；
   * 或者放到 **自定义堆**、**固定内存池**，控制分配策略。

   ```cpp
   struct Heap1 {
       static void* alloc(size_t n);
       static void dealloc(void* p);
   };

   template <typename T, typename Heap>
   struct MyAlloc {
       using value_type = T;
       T* allocate(size_t n) { return static_cast<T*>(Heap::alloc(n * sizeof(T))); }
       void deallocate(T* p, size_t) { Heap::dealloc(p); }
   };

   // 使用 Heap1 的 vector
   std::vector<int, MyAlloc<int, Heap1>> v;
   ```

   👉 要点：**不同堆用不同类型区分**，符合标准对 allocator“等价性”的约束。

---

2. **统计与调试**

   * 统计分配次数、内存用量；
   * 帮助发现性能瓶颈或内存泄漏。

   ```cpp
   template <typename T>
   struct CountingAlloc {
       using value_type = T;
       static inline size_t allocs = 0, frees = 0;
       T* allocate(size_t n) {
           allocs += n;
           return static_cast<T*>(::operator new(n * sizeof(T)));
       }
       void deallocate(T* p, size_t n) noexcept {
           frees += n;
           ::operator delete(p);
       }
   };
   ```

---

## ❌ 不能指望 allocator 做的事

* ❌ **改变对象构造/析构** —— 这是容器的职责，不是 allocator 的。
* ❌ **改变容器增长策略** —— 容器决定如何扩容，allocator 只能“给内存”。
* ❌ **存状态的 allocator** —— 标准假设同类型 allocator 等价，不要用“不同对象表示不同堆”。

---

## 📦 实用建议

* **优先默认**：没特殊需求，就用 `std::allocator`。
* **特殊内存/调试**：需要时再自定义 allocator。
* **类型参数区分资源**：如果要支持多个堆，最好用类型而不是对象来区分。
* **遵守约定**：`allocate(n)` / `deallocate(p,n)` 对称；不要偷偷构造/析构对象。

---

## 📌 小结

自定义分配子是 STL 给你的**内存钩子**，用法合理时很强大：

* ✅ 放数据到特殊内存区域；
* ✅ 做调试和统计；
* ❌ 不要指望它改变容器语义。

👉 **知道能做什么，更要知道不能做什么。默认 allocator 足够，大部分人其实用不到自定义 allocator。**

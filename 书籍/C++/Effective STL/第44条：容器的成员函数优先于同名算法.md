# 第44条：容器的成员函数优先于同名算法

## 一、核心思想

当你想对容器执行某些常见操作（例如 `find()`、`count()`、`remove()`、`sort()` 等）时，**优先考虑容器自身提供的成员函数版本**，而不是使用泛型算法库 `<algorithm>` 中的同名算法版本。

原因很简单：

> **容器自带的成员函数通常更高效、更直观，并能充分利用容器的内部结构。**

---

## 二、举例说明

### 1️⃣ 对比 `set::find` 和 `std::find`

```cpp
std::set<int> s = {1, 2, 3, 4, 5};

// 错误做法：
auto it1 = std::find(s.begin(), s.end(), 3);

// 正确做法：
auto it2 = s.find(3);
```

**区别：**

* `std::find` 是一个通用线性查找算法，复杂度为 **O(n)**；
* `set::find` 利用红黑树结构进行平衡二叉搜索，复杂度为 **O(log n)**。

👉 同样的功能，容器成员函数的性能远高于泛型算法。

---

### 2️⃣ 对比 `list::remove` 和 `std::remove`

```cpp
std::list<int> lst = {1, 2, 3, 2, 4};

// 错误做法：
std::remove(lst.begin(), lst.end(), 2); // 逻辑删除，不能真正移除元素

// 正确做法：
lst.remove(2); // 物理删除，复杂度 O(n)
```

**区别：**

* `std::remove` 并不会真的删除元素，而是将不匹配的元素前移，只是“重排”；
* `list::remove` 真正从链表中移除了节点，操作正确、语义明确。

---

### 3️⃣ 对比 `map::count` 和 `std::count`

```cpp
std::map<int, int> mp = {{1, 10}, {2, 20}, {3, 30}};

// 错误做法：
int n1 = std::count(mp.begin(), mp.end(), std::make_pair(1, 10)); // O(n)

// 正确做法：
int n2 = mp.count(1); // O(log n)
```

**区别：**

* `std::count` 只能线性扫描；
* `map::count` 能直接通过键在平衡树中查找。

---

## 三、为什么容器成员函数更好？

| 优势         | 说明                                                  |
| ---------- | --------------------------------------------------- |
| 🧠 **更直观** | 容器提供的成员函数更贴近容器语义（如 `list.remove()` 表示“删除节点”）        |
| ⚡ **更高效**  | 容器内部结构（红黑树、哈希表、链表等）可被直接利用，避免 O(n) 级别的遍历             |
| 🧩 **更安全** | 不需要使用迭代器范围（避免出错），直接以键或值操作                           |
| 🧰 **更一致** | 成员函数返回类型和容器行为更一致（如 `map::find` 返回 `iterator`，可直接使用） |

---

## 四、常见对比总结表

| 操作目的   | 泛型算法            | 容器成员函数                                                  | 推荐           |
| ------ | --------------- | ------------------------------------------------------- | ------------ |
| 查找元素   | `std::find()`   | `set::find()` / `map::find()` / `unordered_map::find()` | ✅ 成员函数       |
| 统计出现次数 | `std::count()`  | `map::count()` / `unordered_map::count()`               | ✅ 成员函数       |
| 删除元素   | `std::remove()` | `list::remove()` / `set::erase()` / `map::erase()`      | ✅ 成员函数       |
| 排序     | `std::sort()`   | `list::sort()`                                          | ✅ 成员函数（专用结构） |
| 唯一化    | `std::unique()` | `list::unique()`                                        | ✅ 成员函数       |

---

## 五、总结一句话

> 🧩 **当容器提供了某种操作的成员函数时，优先使用它；只有当容器没有提供该功能时，才考虑使用泛型算法。**

---

### 🔍 背后哲学

* 《Effective STL》的许多条款都强调“**理解容器的内部结构，选择最匹配的工具**”；
* 成员函数是“为这个容器量身定制的”，算法是“为所有容器通用的”；
* **能用专用工具的地方，不要用通用工具。**

# 第10条：了解分配子（allocator）的约定和限制）

## 🎯 核心观点

STL 容器的内存管理不是直接用 `new`/`delete`，而是通过 **allocator（分配子）** 完成的。
allocator **只负责原始内存的获取和释放**，构造/析构对象由容器自己完成。
它有一组严格的约定，必须遵守，否则容器行为未定义。

现代 C++ 中，几乎总是用默认的 `std::allocator` 就够了，**除非你有特殊内存需求，否则不要自定义 allocator**。

---

## ✅ allocator 的职责

1. **分配原始内存**：

   ```cpp
   T* p = alloc.allocate(1); // 拿到能容纳 1 个 T 的空间，未构造
   ```

2. **在这块内存上构造对象（placement new）**：

   ```cpp
   new(p) T(value);
   ```

3. **析构对象（手动调用析构函数）**：

   ```cpp
   p->~T();
   ```

4. **释放内存**：

   ```cpp
   alloc.deallocate(p, 1);
   ```

👉 这四步展示了 allocator 的完整约定。

---

## ❌ 常见误区（踩坑示例）

```cpp
MyAllocator<int> alloc;
int* p = alloc.allocate(1);
*p = 42;              // ❌ 直接写值，跳过构造
alloc.deallocate(p,1);// ❌ 没有调用析构
```

问题：

* 如果 `T` 是复杂对象（如 `std::string`），就会发生内存泄漏或未定义行为。

---

## 🛠 为什么要有 allocator？

1. **把“内存管理”和“对象生命周期”分开**

   * 容器可以一次分配一大块内存，但只构造需要的对象
   * 可以析构对象但保留内存，方便复用

2. **支持自定义内存策略**

   * 内存池、共享内存、嵌入式系统特殊区域

3. **性能优化**

   * 避免频繁 `new`/`delete` 带来的开销

---

## 📦 实用建议

| 需求          | 用法 ✅                                     | 说明                  |
| ----------- | ---------------------------------------- | ------------------- |
| 普通容器使用      | `std::vector<int>`（默认用 `std::allocator`） | 默认 allocator 就够用了   |
| 自定义内存策略（少见） | 写一个符合规范的 allocator                       | 必须完全遵守 STL 约定，否则 UB |
| 构造/析构对象     | 容器会帮你处理（placement new / `~T()`）          | allocator 不负责对象生命周期 |

---

## 📌 小结

* allocator **只管理内存**，不构造对象；
* 容器通过 placement new / 析构来控制对象生命周期；
* `allocate` 与 `deallocate` 必须对称使用，参数一致；
* 绝大多数情况下，直接用 **`std::allocator`** 就够了；
* 不要轻易自定义 allocator，除非有特殊需求。

---

👉 一句话总结：
**第10条提醒我们：容器的内存管理依赖 allocator，但它的约定很严格。了解它的作用和限制，避免误用，通常直接用默认的 std::allocator 最安全。** 🚀

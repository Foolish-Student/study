# 第13条：vector 和 string 优先于动态分配的数组

## 🎯 核心观点

* 在 C++ 中，应该**优先使用 `std::vector` 和 `std::string`**，而不是 `new[]/delete[]` 管理的动态数组。
* 理由：容器更安全、更方便、效率不差，并且能无缝结合 STL 算法。
* 书中特别提醒：一些实现的 `string` 可能基于**引用计数（写时拷贝, COW）**，这会带来额外影响，需要理解。

---

## ✅ 为什么 vector / string 更好

1. **RAII，自动释放**

   * 不需要手工写 `delete[]`，避免内存泄漏。

2. **异常安全**

   * 容器析构时能正确释放所有元素。
   * 动态数组在异常下极易泄漏。

3. **灵活扩展**

   * `vector` 会自动扩容；
   * 动态数组必须自己手写“分配新数组 + 拷贝 + 释放旧数组”。

4. **与 STL 算法兼容**

   * `vector` 和 `string` 提供迭代器，可以直接用在 `sort`、`find`、`accumulate` 等算法中。
   * 动态数组只能裸指针 + 长度，接口不统一。

5. **性能并不逊色**

   * `vector` 内部就是一块连续内存，本质与动态数组一致。
   * `string` 在很多实现里还用了 **SSO（小字符串优化）** 或 **COW（引用计数）** 来提升性能。

---

## 📌 关于引用计数 string（COW）

书中特别提醒：在某些标准库实现中，`std::string` 是\*\*引用计数 + 写时拷贝（Copy-On-Write）\*\*实现的：

* **工作方式**

  * 拷贝构造/赋值时，不立刻复制字符数组，而是共享同一块内存；
  * 底层有一个**引用计数器**，统计有多少 `string` 对象共享这块缓冲区；
  * 当某个对象执行写操作时，如果引用计数 > 1，就触发**真正拷贝**，保证修改不影响其他对象。

* **优点**

  * 复制字符串时性能更高（只加计数，不复制数据）。
  * 对于大量只读字符串拷贝，效率比深拷贝好。

* **缺点**

  * 多线程不安全：引用计数更新需要同步，否则竞态。
  * 与 C++11 的移动语义冲突，现代标准已不再推荐。
  * 迭代器或指针可能因为写时分离而失效。

👉 **因此：在现代实现里，大多数 `std::string` 已经弃用 COW，转向 SSO + 移动语义。** 但书里提醒我们，要**知道可能存在 COW 实现，写代码时别依赖它的具体细节**。

---

## ❌ 动态数组的缺陷

```cpp
int* arr = new int[10];
arr[0] = 42;
// ...
delete[] arr; // 容易忘记
```

* 必须手动管理内存，易出错；
* 无法自动扩容；
* 与 STL 算法不兼容；
* 不具备异常安全性。

---

## 🛠 实用建议

* **用 `vector` 替代 `T* + new[]`**：

  ```cpp
  std::vector<int> v(10, 0);
  ```

* **用 `string` 替代 `char* + new[]`**：

  ```cpp
  std::string s = "hello";
  ```

* **注意 string 的实现差异**

  * 不要依赖它是否是 **引用计数（COW）** 或 **小字符串优化（SSO）**；
  * 写代码时假设它就是“值语义容器”，避免和实现绑定。

---

## 📌 小结

* **优先**：`vector` 和 `string`，因为它们比动态数组更安全、更灵活、更好用。
* **谨记**：一些 `string` 实现可能用 **引用计数（COW）**，这对性能有利，但也有线程安全/语义上的陷阱。
* **现代结论**：不要依赖 string 的具体实现细节，写代码时假设它就是“拷贝即独立”。
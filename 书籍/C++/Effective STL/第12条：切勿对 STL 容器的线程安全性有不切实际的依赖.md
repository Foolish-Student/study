# 第12条：切勿对 STL 容器的线程安全性有不切实际的依赖

## 🎯 核心观点

* **STL 容器本身不是线程安全的**。
* 标准只保证：

  * 不同容器上的操作彼此独立，不会互相影响；
  * **多个只读操作**可以安全并发；
  * 但**任何修改操作**（插入、删除、扩容等）如果并发发生，行为未定义。
* 想要线程安全，必须靠 **外部同步机制**（锁、读写锁、并发容器等）。

---

## ✅ 标准的线程安全保证

1. **不同容器彼此独立**

   ```cpp
   std::vector<int> v1, v2;
   // 线程1操作 v1，线程2操作 v2 —— ✅ 安全
   ```

2. **同一容器的多个读操作可以并行**

   ```cpp
   std::vector<int> v = {1,2,3};
   // 多个线程同时遍历 v —— ✅ 安全
   ```

3. **一旦涉及写操作 → 就不安全**

   ```cpp
   std::vector<int> v;
   // 线程1 push_back，线程2 遍历 —— ❌ 未定义行为
   ```

---

## ❌ 错误依赖（常见踩坑）

* 认为 `push_back`/`insert` 是原子的 —— ❌
* 认为 `size()` 等查询函数始终安全 —— ❌（如果另一个线程在改容器，结果未定义）
* 认为迭代器遍历可以和写操作并发 —— ❌（迭代器失效问题）

---

## 🛠 正确做法

1. **外部加锁**

   * 粗粒度：容器级别互斥锁（如 `std::mutex` + `std::lock_guard`）
   * 细粒度：读写锁（读并发，写独占）

   ```cpp
   std::vector<int> v;
   std::mutex m;

   void safe_push(int x) {
       std::lock_guard<std::mutex> lk(m);
       v.push_back(x);
   }
   ```

2. **使用并发容器（替代方案）**

   * Intel TBB: `concurrent_vector`, `concurrent_hash_map`
   * folly: `ConcurrentHashMap`
   * Java/C# 里也有类似 Concurrent Collections

3. **架构层避免共享**

   * 优先使用 **线程局部容器** 或 **消息传递**（生产者-消费者队列），减少锁开销。

---

## 📦 实用建议

* ✅ 读多写少：用读写锁包容器
* ✅ 高并发写：考虑专用并发容器 / 无锁结构
* ✅ 低并发：直接 `std::mutex` + STL 容器就够
* ❌ 不要幻想 STL 自己会保证安全（它的设计目标是**单线程高效**，不是并发安全）

---

## 📌 小结

* **STL 容器默认不是线程安全的**。
* **安全场景只有两个**：不同容器各自用，或同一容器的只读并发。
* 一旦涉及写 → 必须加锁或换用并发容器。
* **不要依赖 STL 容器内部的“偶然安全”，必须显式同步。**


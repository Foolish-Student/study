# 第47条：避免产生“直写型”（write-only）的代码

## 🧩 一、什么是“直写型代码”（Write-Only Code）

“直写型代码”这个词来自老程序员的黑话：

> 意思是——这种代码「写的时候作者能看懂，几天后连他自己都看不懂」。

在 STL 使用中，这种问题非常常见。
比如下面这段：

```cpp
transform(v.begin(), v.end(), v.begin(), bind2nd(multiplies<int>(), 3));
```

它的意思是：把 `v` 中的每个元素都乘以 3。
但初学者、甚至几天后的你，很可能要读半天才能搞清楚这行的含义。

这就是典型的 **“写一次就不想看第二遍”** 的 STL 代码。

---

## ⚙️ 二、为什么 STL 容易写出“直写型代码”

STL 本身功能强大、模板层次复杂，又允许“函数对象嵌套 + 算法组合”，
这很容易写出逻辑正确但极其晦涩的“一行流式代码”。

例如：

```cpp
remove_if(v.begin(), v.end(),
          not1(bind2nd(less<int>(), threshold)));
```

这行代码逻辑是：

> 删除所有 “不小于 threshold” 的元素。

但要理解这一句，你得拆解：

* `less<int>()` → 比较函数；
* `bind2nd(..., threshold)` → 固定右参数；
* `not1(...)` → 取反；
* `remove_if` → 执行过滤。

一个简单的逻辑，却被写得像谜语一样。
这正是 Meyers 所说的 “write-only”——写得漂亮、难懂到爆。

---

## 💡 三、条款 47 的核心思想

> STL 鼓励我们写高抽象代码，但抽象不该牺牲清晰度。
> **要让别人（包括未来的自己）能快速理解这段代码在做什么。**

所以：

* 你**可以用 STL 算法**，但不要堆叠太多函数适配器（`bind1st`, `bind2nd`, `not1` 等）。
* 如果逻辑复杂到必须嵌套好几个适配器，宁可写个小的命名函数对象或 lambda。

---

## ✅ 四、正确做法：清晰胜于花哨

举个例子 👇

### ❌ 不推荐的写法（直写型）

```cpp
remove_if(v.begin(), v.end(), not1(bind2nd(less<int>(), 10)));
```

### ✅ 推荐的写法（清晰易懂）

```cpp
struct GreaterEqualThan10 {
    bool operator()(int x) const { return x >= 10; }
};

remove_if(v.begin(), v.end(), GreaterEqualThan10());
```

或者在现代 C++ 中用 lambda：

```cpp
remove_if(v.begin(), v.end(), [](int x){ return x >= 10; });
```

这行就非常直观了，谁都能看懂。

---

## 🧠 五、总结要点

| 项目          | 说明                                            |
| ----------- | --------------------------------------------- |
| **核心警告**    | 不要写别人（包括你自己）几天后都看不懂的 STL 表达式。                 |
| **“直写型”定义** | 功能正确但过度复杂、可读性差的 STL 组合代码。                     |
| **主要根源**    | 滥用函数适配器（`bind1st`, `not1`, `compose` 等）或多层嵌套。 |
| **解决方法**    | 用自定义函数对象、lambda 表达式或拆分逻辑步骤，让代码意图更直白。          |
| **现代替代**    | C++11 起的 lambda 极大改善了 STL 代码的可读性。             |

---

### 📘 一句话总结

> **STL 的强大在于抽象，但好代码的强大在于清晰。**
> 写给人看的代码，永远比写给编译器的更重要。

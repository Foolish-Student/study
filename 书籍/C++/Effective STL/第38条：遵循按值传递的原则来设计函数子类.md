
# **第38条总结：函数子类按值传递原则**

## 1. **函数子类（Functor）定义**

* **函数子类**是一种重载了 `operator()` 的类，可以像普通函数一样调用。
* 典型用途：

  * 传递给 STL 算法（如 `sort`, `transform`, `for_each`）作为操作函数。
* 例子：

```cpp
struct Add {
    int operator()(int a, int b) const { return a + b; }
};
Add add;
int sum = add(2, 3);  // sum = 5
```

---

## 2. **按值传递的推荐原则**

* **原则**：函数子类对象应尽量 **按值传递**，而不是按引用或指针传递。
* **原因**：

  1. **小对象、拷贝成本低**

     * 函数子类通常只保存少量状态（例如整数或指针）
     * 拷贝代价非常小
  2. **避免悬空引用**

     * STL 算法内部通常会对函数子类进行 **拷贝**
     * 如果传入引用，可能会出现引用失效或悬空的情况
  3. **保持状态一致性**

     * 算法内部可能多次调用或存储副本
     * 按值传递可以保证每个副本的状态独立且正确

---

## 3. **按值传递示例**

```cpp
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

struct Multiply {
    int factor;
    Multiply(int f) : factor(f) {}
    int operator()(int x) const { return x * factor; }
};

int main() {
    vector<int> v = {1, 2, 3};
    vector<int> res(v.size());

    // 将函数子类按值传入 STL 算法
    transform(v.begin(), v.end(), res.begin(), Multiply(2));

    for(int x : res) cout << x << " ";  // 输出：2 4 6
}
```

* `Multiply(2)` 被 **按值传递**
* STL 内部可能会拷贝它以执行操作，但每个副本都保留 `factor` 状态
* 这样就不会出现悬空引用或状态丢失问题

---

## 4. **函数子类内部状态注意事项**

* 函数子类可以保存 **内部状态**（例如计数器、参数值等）
* 如果按引用传递，算法内部拷贝可能导致状态不一致
* 按值传递保证：

  * 每个副本独立，状态正确
  * 算法执行安全可靠

---

## 5. **特殊情况**

* 如果函数子类对象非常大（存储大量数据），可以考虑按 **const 引用** 传递
* 但必须确保引用的生命周期覆盖算法执行过程
* **一般规则**：优先按值传递，既安全又高效

---

## 6. **总结**

1. 函数子类（Functor）是一种可调用对象，可传递给 STL 算法。
2. **按值传递**是 STL 推荐方式：小对象成本低，避免悬空引用，保证状态一致性。
3. STL 内部经常需要 **拷贝函数子类**，按值传递最安全。
4. 内部状态复杂或对象大时可按 const 引用传递，但需注意生命周期。
5. 按值传递原则可以保证算法通用性、安全性和可维护性。

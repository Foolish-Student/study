# **第31条：了解各种与排序相关的选择**

## **核心思想**

STL 提供了多种排序和与排序相关的算法与容器选择，合理选择可以：

* 提升性能
* 减少不必要的复制和比较
* 更好地匹配使用场景

关键点：**不同算法和容器针对不同情况有不同效率和特点**。

---

## **1️⃣ 排序算法选择**

### 1.1 `std::sort`

* **特点**：

  * 对 **随机访问迭代器**（如 `vector`、`deque`）效率最高
  * 平均时间复杂度 **O(n log n)**
  * 不保证稳定性（相等元素顺序可能改变）

* **适用场景**：

  * 对性能要求高
  * 不关心相等元素顺序

---

### 1.2 `std::stable_sort`

* **特点**：

  * 保持相等元素的原始顺序（稳定排序）
  * 时间复杂度 **O(n log n)**，但比 `sort` 稍慢，额外使用空间 **O(n)**

* **适用场景**：

  * 对稳定性有要求的排序
  * 比如按照多个关键字排序时，需要保留先前排序结果

---

### 1.3 `std::partial_sort`

* **特点**：

  * 只排序前 k 个元素到正确位置
  * 剩余元素顺序不保证
  * 时间复杂度 **O(n log k)**

* **适用场景**：

  * 只关心前 k 大/小元素
  * 比全排序更高效

---

### 1.4 `std::nth_element`

* **特点**：

  * 把第 n 个元素放到正确位置
  * 左边元素 ≤ 它，右边元素 ≥ 它
  * 时间复杂度 **O(n)** 平均

* **适用场景**：

  * 找中位数或前 k 个最大/最小元素
  * 不需要完整排序

---

## **2️⃣ 容器选择**

排序和选择的效率也取决于容器类型：

| 容器类型               | 排序算法效率                            | 特点                     |
| ------------------ | --------------------------------- | ---------------------- |
| `vector` / `deque` | 随机访问迭代器 → 可用 `sort`、`stable_sort` | 内存连续或支持随机访问，高效         |
| `list`             | 不支持随机访问 → 只能用 `list::sort`        | 内部链表实现，排序稳定，但不适合随机访问算法 |
| `set` / `multiset` | 自动排序                              | 插入时保持顺序，无需手动调用 sort    |

---

## **3️⃣ 选择标准**

* **性能优先** → 使用 `std::sort` + `vector`
* **稳定性优先** → `std::stable_sort` 或链表 `list::sort`
* **部分排序** → `std::partial_sort` 或 `std::nth_element`
* **容器自带排序** → `set` / `multiset` 适合动态插入并保持有序

---

## **4️⃣ 常见误区**

1. **在 `list` 上使用 `std::sort`** → 无法编译，因为 `list` 不是随机访问迭代器
2. **过度使用 `stable_sort`** → 不需要稳定性时，浪费空间和时间
3. **使用 `partial_sort` 时忽略剩余元素** → 剩余元素顺序不保证

---

### ✅ 核心总结

* STL 提供多种排序方法：**全排序、稳定排序、部分排序、选择算法**
* 不同算法适合不同容器和场景
* **选择原则**：

  1. 关注性能 → `sort` + `vector`
  2. 关注稳定性 → `stable_sort`
  3. 只关心前 k 个 → `partial_sort` 或 `nth_element`
  4. 容器自带排序 → `set` / `multiset`

---

💡 **一句口诀**：

> **“全排序快，稳定慢；部分排序小快；nth 找位置，容器自带省力。”**

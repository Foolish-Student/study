# 第2条：不要试图编写独立于容器类型的代码

## 🎯 核心观点

STL 中不同容器的行为差异很大，尝试写"对所有容器都通用"的模板代码，往往会导致代码复杂、低效、甚至错误。**应针对特定容器编写针对性的代码**，而不是追求"容器无关性"。

---

## 📦 容器间的关键差异

| 特性      | `vector`     | `list`                        | `set` / `map`               |
| ------- | ------------ | ----------------------------- | --------------------------- |
| 元素访问    | 随机访问（O(1))   | 只能线性访问（O(n))                  | 有序但只能按键访问                   |
| 插入/删除效率 | 尾部高效，头部低效    | 任意位置高效                        | 插入需维护排序（对比函数）               |
| 内存布局    | 连续内存         | 分散节点（每个元素独立分配）                | 平衡树节点（红黑树）                  |
| 算法兼容性   | 支持大多数 STL 算法 | 不支持 `sort`, `binary_search` 等 | 不能直接使用 `remove`, `sort` 等算法 |

---

## 🧱 举例说明

### ❌ 错误尝试：对所有容器统一处理

```cpp
template<typename Container>
void sort_and_unique(Container& c) {
    std::sort(c.begin(), c.end());    // 错：不适用于 list/set
    c.erase(std::unique(c.begin(), c.end()), c.end());
}
```

该模板在 `vector` 上可行，但在 `list`（无随机访问迭代器）或 `set`（已经排序，不能修改元素）上会失败。

---

## ✅ 正确做法：为不同容器设计专门的实现

```cpp
void sort_and_unique(std::vector<int>& v) {
    std::sort(v.begin(), v.end());
    v.erase(std::unique(v.begin(), v.end()), v.end());
}

void sort_and_unique(std::list<int>& l) {
    l.sort();
    l.unique();
}
```

---

## 🧠 总结建议

* **STL 容器不是简单替代品**，各自特性差异显著；
* **避免"一招打天下"的模板代码**；
* **理解容器的迭代器类型与算法兼容性** 是写泛型代码的前提；
* 若确实需要支持多种容器，可使用 `iterator_traits` 做判断（代价较高，需谨慎）。

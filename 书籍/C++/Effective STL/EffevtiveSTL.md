# 第1章 容器
## 第1条：慎重选择容器类型

> **核心观点：同容器适用于不同场景，选对容器能极大提升程序性能和可维护性。**

---

### 🌲 容器分类与特点对比

| 容器类型            | 结构/特点                | 插入/删除效率           | 查找效率        | 是否排序 | 特别适合的场景         |
| --------------- | -------------------- | ----------------- | ----------- | ---- | --------------- |
| `vector`        | 连续数组，支持随机访问          | 尾部快 O(1)，中间慢 O(n) | 快速随机访问 O(1) | ❌ 无序 | 频繁随机访问，大量尾部操作   |
| `list`          | 双向链表                 | 任意位置快 O(1)        | 顺序查找 O(n)   | ❌ 无序 | 频繁插入删除，不需要随机访问  |
| `deque`         | 双端队列                 | 两端插入删除快 O(1)      | 快速随机访问 O(1) | ❌ 无序 | 双端插入删除          |
| `set`           | 红黑树实现，自动排序、唯一性       | 插入删除 O(log n)     | 查找 O(log n) | ✅ 有序 | 保证唯一、需要自动排序的数据集 |
| `multiset`      | 类似 `set`，允许重复 key    | 插入删除 O(log n)     | 查找 O(log n) | ✅ 有序 | 统计频次、允许重复元素     |
| `map`           | 键值对，按 key 排序，红黑树实现   | 插入删除 O(log n)     | 查找 O(log n) | ✅ 有序 | 有序映射，查找效率和排序兼顾  |
| `multimap`      | 类似 `map`，允许重复 key    | 插入删除 O(log n)     | 查找 O(log n) | ✅ 有序 | 一对多关系建模（如学生→成绩） |
| `unordered_set` | 哈希表实现，无序，唯一性         | 插入查找平均 O(1)       | 查找 O(1)（均摊） | ❌ 无序 | 快速查找、唯一值集合      |
| `unordered_map` | 类似 `map`，哈希表实现，无序    | 插入查找平均 O(1)       | 查找 O(1)（均摊） | ❌ 无序 | 快速键值映射查找        |
| `bitset`        | 固定长度的位数组（布尔值优化存储）    | 位运算快              | 逐位访问        | ❌ 无序 | 节省空间，处理布尔数组     |
| `rope`          | 平衡树结构的大字符串容器（GCC 扩展） | 插入删除快（中间也快）       | 支持子串操作      | ❌ 无序 | 编辑器、处理长字符串      |

---

### 🛠️ 建议与原则

1. **不要盲目使用 `vector`**：虽然常用，但中间插入删除效率差，不适合频繁修改的场景。
2. **`list` 适合频繁插入/删除，不适合查找**：无随机访问，查找效率低。
3. **使用 `set` / `map` 要知道它们是有序结构**：所有操作为 O(log n)，比 `unordered_*` 慢但有序。
4. **`unordered_*` 系列优于 `set` / `map` 速度快但无序**：适合查找频繁、无需排序。
5. **内存占用考虑**：`list` 由于链表结构，指针开销大；`vector` 更紧凑。

---

### 🔍 实战选择示例

| 需求场景           | 推荐容器                              |
| -------------- | --------------------------------- |
| 快速查找，不要求顺序     | `unordered_map` / `unordered_set` |
| 自动排序，不允许重复     | `set` / `map`                     |
| 需要频繁插入删除（非尾部）  | `list`                            |
| 需要快速随机访问，插入在尾部 | `vector`                          |
| 需要快速两端插入删除     | `deque`                           |
| 操作超长字符串、频繁拼接   | `rope`（非标准）                       |
| 节省布尔值空间        | `bitset`                          |

---

### 📌 小结

> STL 容器众多，各有所长。选择容器时不要凭感觉，而要：
>
> ✅ 明确操作模式 → ✅ 了解容器特性 → ✅ 选择合适容器

📖 正如本节标题所说：“**慎重选择容器类型**” —— 这是高质量 C++ 编程的第一步！

---


## 第2条：不要试图编写独立于容器类型的代码

### 🎯 核心观点

STL 中不同容器的行为差异很大，尝试写“对所有容器都通用”的模板代码，往往会导致代码复杂、低效、甚至错误。**应针对特定容器编写针对性的代码**，而不是追求“容器无关性”。

---

### 📦 容器间的关键差异

| 特性      | `vector`     | `list`                        | `set` / `map`               |
| ------- | ------------ | ----------------------------- | --------------------------- |
| 元素访问    | 随机访问（O(1))   | 只能线性访问（O(n))                  | 有序但只能按键访问                   |
| 插入/删除效率 | 尾部高效，头部低效    | 任意位置高效                        | 插入需维护排序（对比函数）               |
| 内存布局    | 连续内存         | 分散节点（每个元素独立分配）                | 平衡树节点（红黑树）                  |
| 算法兼容性   | 支持大多数 STL 算法 | 不支持 `sort`, `binary_search` 等 | 不能直接使用 `remove`, `sort` 等算法 |

---

### 🧱 举例说明

#### ❌ 错误尝试：对所有容器统一处理

```cpp
template<typename Container>
void sort_and_unique(Container& c) {
    std::sort(c.begin(), c.end());    // 错：不适用于 list/set
    c.erase(std::unique(c.begin(), c.end()), c.end());
}
```

该模板在 `vector` 上可行，但在 `list`（无随机访问迭代器）或 `set`（已经排序，不能修改元素）上会失败。

---

### ✅ 正确做法：为不同容器设计专门的实现

```cpp
void sort_and_unique(std::vector<int>& v) {
    std::sort(v.begin(), v.end());
    v.erase(std::unique(v.begin(), v.end()), v.end());
}

void sort_and_unique(std::list<int>& l) {
    l.sort();
    l.unique();
}
```

---

### 🧠 总结建议

* **STL 容器不是简单替代品**，各自特性差异显著；
* **避免“一招打天下”的模板代码**；
* **理解容器的迭代器类型与算法兼容性** 是写泛型代码的前提；
* 若确实需要支持多种容器，可使用 `iterator_traits` 做判断（代价较高，需谨慎）。

---


## 第3条：确保容器中的对象拷贝正确而高效

### 🎯 核心观点

STL 容器在执行插入、删除、排序等操作时，**大量依赖对象的拷贝构造和赋值操作**。如果你的类型没有正确实现这些操作，可能导致：

* **程序错误**（浅拷贝引发悬垂指针、重复释放等问题）；
* **性能瓶颈**（不必要的深拷贝或资源分配）。

---

### 📦 STL 容器操作中何时发生拷贝？

| 操作                     | 是否拷贝对象      |
| ---------------------- | ----------- |
| `push_back` / `insert` | 是，拷贝或移动对象   |
| `resize`               | 是，默认构造 + 拷贝 |
| `sort`                 | 是，交换需要拷贝或移动 |
| `erase`                | 有时伴随元素移动    |

---

### ⚠️ 拷贝不当带来的问题

#### ❌ 错误示例：浅拷贝导致悬垂指针

```cpp
class Bad {
public:
    Bad() { data = new int[100]; }
    ~Bad() { delete[] data; }
    Bad(const Bad& other) { data = other.data; }  // 浅拷贝：危险！
private:
    int* data;
};

std::vector<Bad> v;
v.push_back(Bad());  // 多次 push_back 会 double free！
```

#### ✅ 正确示例：深拷贝或使用智能指针

```cpp
class Good {
public:
    Good() { data = std::make_shared<std::vector<int>>(100); }
private:
    std::shared_ptr<std::vector<int>> data;
};
```

---

### 🚀 高效性：避免不必要的拷贝

#### 使用 `emplace` 替代 `insert` / `push_back`

```cpp
std::vector<MyClass> v;
v.emplace_back(arg1, arg2);  // 直接构造，无需额外拷贝
```

#### 使用移动语义（C++11 及以上）

```cpp
MyClass(MyClass&& other);          // 移动构造
MyClass& operator=(MyClass&& rhs); // 移动赋值
```

若对象支持移动操作，STL 优先使用移动而非拷贝，提高性能。

---

### ✅ 建议总结

* **总是实现自己的拷贝构造函数和赋值操作符**（遵循 Rule of Three / Five / Zero）；
* **如果不需要拷贝，禁止拷贝（如删除构造函数）**；
* **为性能敏感的对象实现移动语义**；
* **插入容器时优先使用 `emplace` 和 `std::move`**；
* 使用 STL 容器时，**你的类型必须是值语义（Value Semantics）良好市民**。

---


## 第4条：调用 `empty()` 而不是检查 `size() == 0`

### 🎯 核心观点

在判断 STL 容器是否为空时，**应优先使用 `empty()` 而不是 `size() == 0`**，因为：

1. **语义更清晰**
2. **更高效（对某些容器而言）**
3. **更通用，适用于所有标准容器**

---

### ✅ 推荐写法

```cpp
if (c.empty()) {
    // 更清晰、更安全
}
```

---

### ❌ 不推荐写法

```cpp
if (c.size() == 0) {
    // 可读性差，效率可能低
}
```

---

### 🛠 为什么 `empty()` 更高效？

对于某些容器（如 `list`, `map`），`size()` 可能是 **O(n)**：

* 早期 STL 实现中（特别是 pre-C++11），`list::size()` 并不缓存元素个数
* 每次调用都需要遍历整个链表来计数

而 `empty()` 通常只需判断头尾是否相等，或指针是否为空，**效率为 O(1)**，且在所有容器中都是常数时间。

---

### 📦 `empty()` 的额外优势

| 特性    | `empty()` ✅  | `size() == 0` ❌  |
| ----- | ------------ | ---------------- |
| 时间复杂度 | 恒定 O(1)      | 有的容器可能是 O(n)     |
| 可读性   | 语义清晰         | 逻辑性较弱            |
| 安全性   | 不涉及整数比较      | 容易出错或遗漏          |
| 泛型友好性 | 所有 STL 容器都支持 | 有些容器不推荐用 size 判断 |

---

### ✅ 实用建议

* 判断空容器时：**一律使用 `empty()`**
* 使用算法如 `while (!c.empty())` 替代 `while (c.size() > 0)`
* 写模板/泛型代码时也应优先使用 `empty()`，避免容器差异带来的 bug

---

### 📌 小结

> 使用 `empty()` 是更安全、更快、更 STL 风格的做法。
> 它不仅是性能优化的建议，也是代码风格和可维护性的体现。

---

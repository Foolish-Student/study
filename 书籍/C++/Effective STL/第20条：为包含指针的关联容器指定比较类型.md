## 第 20 条：为包含指针的关联容器指定比较类型

### 📌 背景

* STL 的有序关联容器（如 `std::set`, `std::map`）在内部使用 **比较函数（Compare）** 来维持顺序和平衡。
* 默认比较器是 `std::less<T>`，其本质是用 `operator<`。
* 如果容器里存的是 **指针类型（如 `T*`）**，默认比较会比较 **指针的地址**，而不是指向对象的内容。

---

### 📌 问题

1. **默认行为不符合直觉**

   ```cpp
   std::set<std::string*> s;
   s.insert(new std::string("Apple"));
   s.insert(new std::string("Banana"));
   s.insert(new std::string("Cherry"));
   ```

   * 默认比较的是 **指针地址**，所以集合中元素的顺序取决于堆分配的位置。
   * 结果是不可预测的，也无法按字母顺序访问。

2. **查找逻辑出错**

   * 用 `s.find(new std::string("Apple"))` 会失败，即使容器里已有 `"Apple"`，因为比较的是 **地址** 而不是内容。

---

### 📌 解决方案

👉 为容器 **显式指定比较器**，让它比较指针所指向对象的内容。

示例 1：使用函数对象

```cpp
struct DerefLess {
    bool operator()(const std::string* lhs, const std::string* rhs) const {
        return *lhs < *rhs;  // 比较内容，而不是地址
    }
};

std::set<std::string*, DerefLess> s;
s.insert(new std::string("Apple"));
s.insert(new std::string("Banana"));
s.insert(new std::string("Cherry"));
```

输出时就是按字母顺序：`Apple, Banana, Cherry`。

---

### 📌 补充：智能指针

* 如果用 `std::unique_ptr<T>` 或 `std::shared_ptr<T>` 存对象，默认比较仍然是比较 **指针本身**，而不是所指内容。
* 同样需要自定义比较器。

示例 2：智能指针

```cpp
struct DerefLessSmart {
    bool operator()(const std::unique_ptr<std::string>& lhs,
                    const std::unique_ptr<std::string>& rhs) const {
        return *lhs < *rhs;
    }
};

std::set<std::unique_ptr<std::string>, DerefLessSmart> s;
s.insert(std::make_unique<std::string>("Banana"));
s.insert(std::make_unique<std::string>("Apple"));
```

---

### 📌 最佳实践

1. **永远不要依赖指针地址排序**
   除非确实需要比较地址，否则应该比较对象内容。

2. **定义符合语义的比较器**
   根据业务逻辑决定比较准则（字典序、大小写不敏感、数值大小等）。

3. **考虑智能指针和内存管理**
   在 `set/map` 中存裸指针容易造成内存泄漏，推荐存智能指针并指定比较器。

---

### ✅ 总结

* **问题**：在关联容器中存指针时，默认比较的是 **地址**，而不是 **对象内容**，可能导致排序和查找行为异常。
* **解决**：为容器提供自定义比较器，显式比较 **指向对象的值**。
* **建议**：配合智能指针使用，避免内存泄漏，比较逻辑清晰可靠。
